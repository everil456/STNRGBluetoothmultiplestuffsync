###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        09/Feb/2015  18:59:32
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects V2\Project\BLE_Chat_Server 2\src\BLE_Chat_main.c
#    Command line =  
#        "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects V2\Project\BLE_Chat_Server 2\src\BLE_Chat_main.c" -D
#        USE_STDPERIPH_DRIVER -D STM32L1XX_MD -D SYSCLK_FREQ_HSI_32MHz -D
#        ENABLE_USB -D ENABLE_USB_PRINTF -D SERVER=1 -lcN
#        "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects V2\Project\BLE_Chat_Server 2\EWARM\Server\List\"
#        --diag_suppress Pa050 -o "C:\Users\Matthew\Documents\2014 -
#        2015\Senior Project\Bluetooth code\Projects V2\Project\BLE_Chat_Server
#        2\EWARM\Server\Obj\" --debug --endian=little --cpu=Cortex-M3 -e
#        --fpu=None --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects V2\Project\BLE_Chat_Server 2\EWARM\..\inc\" -I
#        "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects V2\Project\BLE_Chat_Server 2\EWARM\..\..\..\Bluetooth
#        LE\SimpleBlueNRG_HCI\" -I "C:\Users\Matthew\Documents\2014 -
#        2015\Senior Project\Bluetooth code\Projects V2\Project\BLE_Chat_Server
#        2\EWARM\..\..\..\Bluetooth LE\SimpleBlueNRG_HCI\includes\" -I
#        "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects V2\Project\BLE_Chat_Server
#        2\EWARM\..\..\..\platform\STM32L1XX\" -I
#        "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects V2\Project\BLE_Chat_Server
#        2\EWARM\..\..\..\platform\STM32L1XX\Libraries\" -I
#        "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects V2\Project\BLE_Chat_Server
#        2\EWARM\..\..\..\platform\STM32L1XX\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\"
#        -I "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects V2\Project\BLE_Chat_Server
#        2\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32_USB-FS-Device_Driver\inc\"
#        -I "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects V2\Project\BLE_Chat_Server
#        2\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32L1xx_StdPeriph_Driver\inc\"
#        -I "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects V2\Project\BLE_Chat_Server
#        2\EWARM\..\..\..\platform\STM32L1XX\Libraries\I2C\inc\" -I
#        "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects V2\Project\BLE_Chat_Server
#        2\EWARM\..\..\..\platform\STM32L1XX\Libraries\LIS3DH\inc\" -I
#        "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects V2\Project\BLE_Chat_Server
#        2\EWARM\..\..\..\platform\STM32L1XX\Libraries\STLM75\inc\" -I
#        "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects V2\Project\BLE_Chat_Server
#        2\EWARM\..\..\..\platform\STM32L1XX\Libraries\HTS221\inc\" -I
#        "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects V2\Project\BLE_Chat_Server
#        2\EWARM\..\..\..\platform\STM32L1XX\Libraries\LPS25H\inc\" -I
#        "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects V2\Project\BLE_Chat_Server
#        2\EWARM\..\..\..\platform\STM32L1XX\Libraries\SDK_Eval_STM32L\inc\"
#        -Ohs --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects V2\Project\BLE_Chat_Server
#        2\EWARM\Server\List\BLE_Chat_main.lst
#    Object file  =  
#        C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects V2\Project\BLE_Chat_Server
#        2\EWARM\Server\Obj\BLE_Chat_main.o
#
###############################################################################

C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth code\Projects V2\Project\BLE_Chat_Server 2\src\BLE_Chat_main.c
      1          /******************** (C) COPYRIGHT 2014 STMicroelectronics ********************
      2          * File Name          : BLE_Chat_main.c
      3          * Author             : AMS - AAS Division
      4          * Version            : V1.0.1
      5          * Date               : 10-February-2014
      6          * Description        : BlueNRG main file for Chat demo
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          /**
     16           * @file  BLE_Chat_main.c
     17           * @brief This is a Chat demo that shows how to implement a simple 2-way communication between two BlueNRG devices.
     18           *
     19           * <!-- Copyright 2014 by STMicroelectronics.  All rights reserved.       *80*-->
     20          
     21          * \section IAR_project IAR project
     22            To use the project with IAR Embedded Workbench for ARM, please follow the instructions below:
     23            -# Open the Embedded Workbench for ARM.
     24            -# From the File->Open->Workspace menu, open the IAR workspace
     25               <tt> ...\\Projects\\Project\\BLE_Chat\\EWARM\\BLE_Chat.eww </tt>
     26            -# Select desired configuration to build
     27            -# Select Project->Rebuild All. This will recompile and link the entire application
     28            -# To download the binary image, please connect STLink to JTAG connector  in your board (if available).
     29            -# Select Project->Download and Debug to download the related binary image.
     30            -# Alternatively, open the BlueNRG GUI, put the board in DFU mode and download the built binary image.
     31            -# Connect the application board to a PC USB port. Open a hyperterminal on the
     32               corresponding USB virtual COMx port with the configuration as described in \ref Serial_IO.
     33          
     34          * \subsection IAR_project_configurations IAR project configurations
     35          
     36            - \c Client - Client role configuration 
     37            - \c Server - Server role configuration
     38            - \c Client_throughput - Client role configuration for throughput test
     39            - \c Server_throughput - Server role configuration for throughput test
     40          
     41          * \section Prebuilt_images Prebuilt images
     42            - BLE_Chat_Client.hex, BLE_Chat_Server.hex 
     43           
     44          * \section Jumper_settings Jumper settings
     45          @table
     46          ------------------------------------------------------
     47          | Jumper name       |  Description                   | 
     48          ------------------------------------------------------
     49          | JP1, if available | USB or Battery supply position | 
     50          
     51          @endtable 
     52          
     53          
     54          * \section Board_supported Board supported
     55          @table
     56          | Board name      | Board revision | NOTE        |
     57          --------------------------------------------------
     58          | STEVAL-IDB002V1 | 3.0            | Eval Kit    |
     59          | STEVAL-IDB003V1 | 1.0            | USB Dongle  |
     60          @endtable
     61          
     62          * \section Serial_IO Serial I/O
     63            The application will listen for keys typed in one node and, on return press, it will send them to the remote node.
     64            The remote node will listen for RF messages and it will output them in the serial port.
     65            In other words everything typed in one node will be visible to the other node and viceversa.
     66          @table
     67          | Parameter name  | Value          | Unit        |
     68          --------------------------------------------------
     69          | Baudrate        | 115200         | bit/sec     |
     70          | Data bits       | 8              | bit         |
     71          | Parity          | None           | bit         |
     72          | Stop bits       | 1              | bit         |
     73          @endtable
     74          
     75          * \section LEDs_description LEDs description
     76          @table
     77          |                  | STEVAL-IDB002V1 | STEVAL-IDB003V1 |                 
     78          | LED name         | Client/Server   | Client/Server   | 
     79          --------------------------------------------------------
     80          | D1               | Not used        | NA              |        
     81          | D2               | Not used        | Not used        |     
     82          | D3               | Not used        | Not used        |     
     83          | D4               | Not used        | NA              |      
     84          | D5               | Not used        | NA              |       
     85          | D6               | Not used        | NA              |       
     86          @endtable
     87           - NA : Not Applicable;
     88          
     89          * \section Buttons_description Buttons description
     90          @table
     91          |                  | STEVAL-IDB002V1 | STEVAL-IDB003V1 |                 
     92          | Button name      | Client/Server   | Client/Server   | 
     93          --------------------------------------------------------
     94          | RESET            | X               | NA              |  
     95          | Push Button      | Not used        | NA              |   
     96          | Jostick Sel      | Not used        | NA              |    
     97          | SW1              | NA              | Not used        |     
     98          | SW2              | NA              | Not used        |       
     99          @endtable
    100           - NA : Not Applicable;
    101          
    102          * \section DFU_Activation  DFU activation
    103          BlueNRG boards are preprogrammed with a DFU application which allows to upload the 
    104          STM32L micro with a selected binary image through USB. Follow list of actions 
    105          for activating DFU on each supported platforms
    106          @table
    107          | Board  name          | Event                                             | Note               |
    108          ------------------------------------------------------------------------------------------------|
    109          | STEVAL-IDB002V1      | Press RESET and Push Button. Release RESET button | LED D2 is toggling |  
    110          | STEVAL-IDB003V1      | Press SW1 button and plug USB dongle on a PC port | LED D3 is toggling |  
    111          @endtable
    112          
    113          * \section Usage Usage
    114          
    115          This Chat demo has  are 2 roles:
    116           - The server that expose the Chat service. It is the slave.
    117           - The client that uses the Chat service. It is the master.
    118          
    119          The Chat Service contains 2 Characteristics:
    120           -# The TX Characteristic: the client can enable notifications on this characteristic. When the server has data to be sent, it will send notifications which will contains the value of the TX Characteristic
    121           -# The RX Characteristic: it is a writable caracteristic. When the client has data to be sent to the server, it will write a value into this characteristic.
    122          
    123          The maximum length of the characteristic value is 20 bytes.
    124          
    125          NOTES:
    126           - The Client_throughput and Server_throughput workspaces allow to target a throughput test (THROUGHPUT_TEST define on the preprocessor options on both workspaces).
    127           - Program the client on one BlueNRG platform and reset it. The platform will be seen on the PC as a virtual COM port. Open the port in a serial terminal emulator. Client will start 4 seconds after reset.
    128           - Program the server on a second BlueNRG platform and reset it. The two platforms will try to establish a connection. As soon as they get connected, the slave will 
    129             send notification to the client of 20 bytes (200 notifications). 
    130           - After all the notifications are received, the measured application throughput will be displayed.
    131          
    132          **/
    133          /** @addtogroup BlueNRG_demonstrations_applications
    134           * BlueNRG Chat demo \see BLE_Chat_main.c for documentation.
    135           *
    136           *@{
    137           */
    138          
    139          /** @} */
    140          /** \cond DOXYGEN_SHOULD_SKIP_THIS
    141           */
    142          /* Includes ------------------------------------------------------------------*/
    143          #include "stm32l1xx.h"
    144          #include "usb_lib.h"
    145          #include "hw_config.h"
    146          #include "hal_types.h"
    147          #include "hci.h"
    148          #include "bluenrg_aci.h"
    149          #include "gp_timer.h"
    150          #include "hal.h"
    151          #include "osal.h"
    152          #include "gatt_db.h"
    153          #include "gatt_server.h"
    154          #include "hci_const.h"
    155          #include "gap.h"
    156          #include "sm.h"
    157          #include "app_state.h"
    158          #include "led.h"
    159          #include "push_button.h"
    160          #include "timer.h"
    161          #include <stdio.h>
    162          
    163          #include "SDK_EVAL_Config.h"
    164          
    165          /* External variables --------------------------------------------------------*/
    166          /* Private typedef -----------------------------------------------------------*/
    167          /* Private defines -----------------------------------------------------------*/
    168          /** 
    169            * @brief  Enable debug printf's
    170            */ 
    171          #ifndef DEBUG
    172          #define DEBUG 1
    173          #endif
    174                
    175          #define REQUEST_CONN_PARAM_UPDATE 0
    176          
    177          /* Private macros ------------------------------------------------------------*/
    178          #if DEBUG
    179          #include <stdio.h>
    180          #define PRINTF(...) printf(__VA_ARGS__)
    181          #else
    182          #define PRINTF(...)
    183          #endif
    184          
    185          #define NUM_PACKETS 200 // Only used for throughput test (define THROUGHPUT_TEST)
    186          
    187          #ifndef VECTOR_TABLE_BASE_ADDRESS 
    188          /* default configuration: DFU upgrade is supported */
    189          #define VECTOR_TABLE_BASE_ADDRESS            (0x3000)
    190          #endif
    191          
    192          /* Private variables ---------------------------------------------------------*/
    193          volatile int app_flags = SET_CONNECTABLE;
    194          volatile uint16_t connection_handle = 0;
    195          extern uint16_t chatServHandle, TXCharHandle, RXCharHandle;
    196          struct timer l2cap_req_timer;
    197          
    198          /** 
    199            * @brief  Handle of TX,RX  Characteristics.
    200            */ 
    201          #ifdef CLIENT
    202          uint16_t tx_handle;
    203          uint16_t rx_handle;
    204          #endif 
    205          
    206          
    207          /* Private function prototypes -----------------------------------------------*/
    208          void Make_Connection(void);
    209          void User_Process(void);
    210          
    211          /* Private functions ---------------------------------------------------------*/
    212          
    213          /*  User Function where serial received data should be processed */
    214          void processInputData(uint8_t * rx_data, uint16_t data_size);
    215          
    216          /*******************************************************************************
    217          * Function Name  : main.
    218          * Description    : Main routine.
    219          * Input          : None.
    220          * Output         : None.
    221          * Return         : None.
    222          *******************************************************************************/
    223          int main(void)
    224          {
    225              int ret;
    226              
    227              NVIC_SetVectorTable(NVIC_VectTab_FLASH, VECTOR_TABLE_BASE_ADDRESS);
    228              
    229              /* Identify BlueNRG platform */
    230              SdkEvalIdentification();
    231          
    232              RCC_Configuration();
    233              
    234              /* Init I/O ports */
    235              Init_GPIOs ();
    236              
    237              PWR_PVDCmd(DISABLE);
    238              
    239              /* Initialize LEDs */
    240              initLED(0);
    241              initLED(3);
    242              initLED(4);
    243              
    244              /* Initilize event */
    245              initTimer(2,1000);
    246              enableTimerInterrupt(2);
    247              initTimer(4,100);
    248              enableTimerInterrupt(4);
    249              initTimer(6,5000);
    250              enableTimerInterrupt(6);
    251              
    252              
    253              /* Disable FLASH during Sleep  */
    254              FLASH_SLEEPPowerDownCmd(ENABLE);
    255              
    256              /* Enable Ultra low power mode */
    257              PWR_UltraLowPowerCmd(ENABLE);
    258              
    259              PWR_FastWakeUpCmd(ENABLE);
    260              
    261              NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
    262              
    263              Clock_Init();
    264              
    265              /* Delay needed only to be able to acces the JTAG interface after reset
    266              if it will be disabled later. */
    267              Clock_Wait(500);    
    268              
    269              /* Configure I/O communication channel:
    270                 It requires the void IO_Receive_Data(uint8_t * rx_data, uint16_t data_size) function
    271                 where user received data should be processed */
    272              SdkEval_IO_Config(processInputData);
    273              
    274              /* Delay for debug purpose, in order to see printed data at startup. */
    275              for(int i = 0; i < 100 ; i++){
    276                  printf(".");
    277                  Clock_Wait(70);
    278              }
    279          
    280              HCI_Init();
    281              
    282              /* Init SPI interface */
    283              SdkEvalSpiInit(SPI_MODE_EXTI);
    284              BlueNRG_RST(); 
    285              
    286              {
    287          #if CLIENT
    288                  uint8_t bdaddr[] = {0xbb, 0x00, 0x00, 0xE1, 0x80, 0x02};
    289          #else
    290                  uint8_t bdaddr[] = {0xcc, 0x00, 0x00, 0xE1, 0x80, 0x02};
    291          #endif
    292                  ret = aci_hal_write_config_data(CONFIG_DATA_PUBADDR_OFFSET, CONFIG_DATA_PUBADDR_LEN,
    293                                                  bdaddr);
    294                  if(ret){
    295                      PRINTF("Setting BD_ADDR failed.\n");
    296                  }
    297              }
    298              
    299              ret = aci_gatt_init();    
    300              if(ret){
    301                  PRINTF("GATT_Init failed.\n");
    302              }
    303              
    304              {
    305                  uint16_t service_handle, dev_name_char_handle, appearance_char_handle;
    306          #if SERVER
    307                  ret = aci_gap_init(GAP_PERIPHERAL_ROLE, &service_handle, &dev_name_char_handle, &appearance_char_handle);
    308                  const char *name = "BlueNRG2";  
    309                        ret = aci_gatt_update_char_value(service_handle, dev_name_char_handle, 0, 8, (uint8_t *)name);        
    310                        if(ret){
    311                          PRINTF("aci_gatt_update_char_value failed.\n");
    312                        }
    313          #else
    314                  ret = aci_gap_init(GAP_CENTRAL_ROLE, &service_handle, &dev_name_char_handle, &appearance_char_handle);
    315          #endif
    316                  if(ret){
    317                      PRINTF("GAP_Init failed.\n");
    318                  }
    319              }
    320            
    321              /*ret = aci_gap_set_auth_requirement(MITM_PROTECTION_REQUIRED,
    322                                                 OOB_AUTH_DATA_ABSENT,
    323                                                 NULL,
    324                                                 7,
    325                                                 16,
    326                                                 USE_FIXED_PIN_FOR_PAIRING,       //*************************************
    327                                                 123456,
    328                                                 BONDING);
    329              PRINTF("BLE Stack Initialized.\r\n");*/
    330              
    331          #if  SERVER
    332              PRINTF("SERVER: BLE Stack Initialized (platform: %d)\n\r", SdkEvalGetVersion());
    333              ret = Add_Chat_Service();
    334              
    335              if(ret == BLE_STATUS_SUCCESS)
    336                  PRINTF("Service added successfully.\r\n");
    337              else
    338                  PRINTF("Error while adding service.\r\n");
    339              
    340          #else
    341              PRINTF("CLIENT: BLE Stack Initialized  (platform: %d)\n\r", SdkEvalGetVersion());
    342          #endif 
    343              
    344              /* -2 dBm output power */
    345              ret = aci_hal_set_tx_power_level(1,4);
    346                  
    347              while(1)
    348              { 
    349                  HCI_Process();
    350                  User_Process();
    351                  //Clock_Wait(10000);
    352              }
    353          }
    354          
    355          /**
    356            * @brief  Make the device connectable
    357            * @param  None 
    358            * @retval None
    359            */
    360          void Make_Connection(void)
    361          {  
    362              tBleStatus ret;
    363              
    364              
    365          #if CLIENT
    366              tBDAddr bdaddr = {0xaa, 0x00, 0x00, 0xE1, 0x80, 0x02};
    367              
    368              //ret = aci_gap_create_connection(0x4000, 0x4000, PUBLIC_ADDR, bdaddr, PUBLIC_ADDR, 40, 40, 0, 60, 2000 , 2000); 
    369              ret = aci_gap_create_connection(0x4000, 0x4000, PUBLIC_ADDR, bdaddr, PUBLIC_ADDR, 9, 9, 0, 60, 1000 , 1000); 
    370              if (ret != 0){
    371                  PRINTF("Error while starting connection.\n");
    372                  Clock_Wait(100);        
    373          	}
    374          #else
    375              
    376              const char local_name[] = {AD_TYPE_COMPLETE_LOCAL_NAME,'B','l','u','e','N','R','G','_','C','h','a','t','2'};
    377              
    378              /* disable scan response */
    379              //hci_le_set_scan_resp_data(0,NULL);
    380              
    381              PRINTF("General Discoverable Mode ");
    382              PRINTF("General Discoverable Mode ");
    383              ret = aci_gap_set_discoverable(ADV_IND, 0x00a0, 0x00a0, PUBLIC_ADDR, 0x00,
    384                                             14, local_name, 0, 0x0, 0, 0);
    385          
    386              PRINTF("%d\n\r",ret);
    387          #endif
    388          }
    389          
    390          /**
    391            * @brief  This function is called when there is a LE Connection Complete event.
    392            * @param  addr Address of peer device
    393            * @param  handle Connection handle
    394            * @retval None
    395            */
    396          void GAP_ConnectionComplete_CB(uint8_t addr[6], uint16_t handle)
    397          {    
    398              APP_FLAG_SET(CONNECTED); 
    399              connection_handle = handle;
    400              
    401              //Show connection with LED
    402              turnLED(3,ON);
    403              
    404              PRINTF("Connected to device:");
    405              for(int i = 5; i > 0; i--){
    406                  PRINTF("%02X-", addr[i]);
    407              }
    408              PRINTF("%02X\n\r", addr[0]);
    409              
    410          #if REQUEST_CONN_PARAM_UPDATE
    411              APP_FLAG_CLEAR(L2CAP_PARAM_UPD_SENT);
    412              Timer_Set(&l2cap_req_timer, CLOCK_SECOND*2);
    413          #endif
    414              
    415          }
    416          
    417          /**
    418            * @brief  This function is called when the peer device get disconnected.
    419            * @param  None 
    420            * @retval None
    421            */
    422          void GAP_DisconnectionComplete_CB(void)
    423          {
    424            //Turn off connection LED
    425            turnLED(3,OFF);
    426              APP_FLAG_CLEAR(CONNECTED);
    427              PRINTF("Disconnected\n\r");
    428              /* Make the device connectable again. */
    429              APP_FLAG_SET(SET_CONNECTABLE);
    430              APP_FLAG_CLEAR(NOTIFICATIONS_ENABLED);
    431              
    432              APP_FLAG_CLEAR(START_READ_TX_CHAR_HANDLE);
    433              APP_FLAG_CLEAR(END_READ_TX_CHAR_HANDLE);
    434              APP_FLAG_CLEAR(START_READ_RX_CHAR_HANDLE); 
    435              APP_FLAG_CLEAR(END_READ_RX_CHAR_HANDLE); 
    436          }
    437          
    438          /**
    439            * @brief  This function is called when there is a notification from the sever.
    440            * @param  attr_handle Handle of the attribute
    441            * @param  attr_len    Length of attribute value in the notification
    442            * @param  attr_value  Attribute value in the notification
    443            * @retval None
    444            */
    445          void GATT_Notification_CB(uint16_t attr_handle, uint8_t attr_len, uint8_t *attr_value)
    446          {
    447          #if THROUGHPUT_TEST && CLIENT
    448              static tClockTime time, time2;
    449              static int packets=0;     
    450              
    451              if(attr_handle == tx_handle+1){ 
    452                  if(packets==0){
    453                      printf("Test start\n\r");
    454                      time = Clock_Time();
    455                  }
    456                  
    457                  for(int i = 0; i < attr_len; i++)
    458                      printf("%c", attr_value[i]);
    459                  
    460                  printf("[RX: %d]", packets);//TBR
    461                  
    462                  packets++;
    463                  
    464                  if(packets == NUM_PACKETS){
    465                      time2 = Clock_Time();
    466                      tClockTime diff = time2-time;
    467                      printf("\n%d packets. Elapsed time: %d ms. App throughput: %.2f kbps.\n\r", NUM_PACKETS, diff, (float)NUM_PACKETS*20*8/diff);
    468                  }        
    469                  
    470              }
    471          #elif CLIENT
    472              
    473              if(attr_handle == tx_handle+1){
    474                for(int i = 0; i < attr_len; i++)
    475                    printf("%c", attr_value[i]);
    476              }
    477          #endif
    478          }
    479          
    480          void User_Process(void)
    481          {
    482              if(APP_FLAG(SET_CONNECTABLE)){
    483                  Make_Connection();
    484                  APP_FLAG_CLEAR(SET_CONNECTABLE);
    485              }
    486          
    487          #if REQUEST_CONN_PARAM_UPDATE    
    488              if(APP_FLAG(CONNECTED) && !APP_FLAG(L2CAP_PARAM_UPD_SENT) && Timer_Expired(&l2cap_req_timer)){
    489                  aci_l2cap_connection_parameter_update_request(connection_handle, 8, 16, 0, 600);
    490                  APP_FLAG_SET(L2CAP_PARAM_UPD_SENT);
    491              }
    492          #endif
    493              
    494          #if CLIENT
    495              
    496              
    497              /* Start TX handle Characteristic discovery if not yet done */
    498              if (APP_FLAG(CONNECTED) && !APP_FLAG(END_READ_TX_CHAR_HANDLE))
    499              {
    500                if (!APP_FLAG(START_READ_TX_CHAR_HANDLE))
    501                {
    502                  /* Discovery TX characteristic handle by UUID 128 bits */
    503                  
    504                   const uint8_t charUuid128_TX[16] = {0x66,0x9a,0x0c,0x20,0x00,0x08,0x96,0x9e,0xe2,0x11,0x9e,0xb1,0xe1,0xf2,0x73,0xd9};
    505                   
    506                   aci_gatt_disc_charac_by_uuid(connection_handle, 0x0001, 0xFFFF,UUID_TYPE_128,
    507                                                             charUuid128_TX);
    508                   APP_FLAG_SET(START_READ_TX_CHAR_HANDLE);
    509                }
    510              }
    511              /* Start RX handle Characteristic discovery if not yet done */
    512              else if (APP_FLAG(CONNECTED) && !APP_FLAG(END_READ_RX_CHAR_HANDLE))
    513              {
    514                /* Discovery RX characteristic handle by UUID 128 bits */
    515                if (!APP_FLAG(START_READ_RX_CHAR_HANDLE))
    516                {
    517                  /* Discovery TX characteristic handle by UUID 128 bits */
    518                  
    519                   const uint8_t charUuid128_RX[16] = {0x66,0x9a,0x0c,0x20,0x00,0x08,0x96,0x9e,0xe2,0x11,0x9e,0xb1,0xe2,0xf2,0x73,0xd9};
    520                   aci_gatt_disc_charac_by_uuid(connection_handle, 0x0001, 0xFFFF,UUID_TYPE_128,
    521                                                             charUuid128_RX);
    522                   APP_FLAG_SET(START_READ_RX_CHAR_HANDLE);
    523                 }
    524              }
    525              
    526              if(APP_FLAG(CONNECTED) && APP_FLAG(END_READ_TX_CHAR_HANDLE) && APP_FLAG(END_READ_RX_CHAR_HANDLE) && !APP_FLAG(NOTIFICATIONS_ENABLED)){
    527                  uint8_t client_char_conf_data[] = {0x01, 0x00}; // Enable notifications
    528                  struct timer t;
    529                  Timer_Set(&t, CLOCK_SECOND*10);
    530                  
    531                  while(aci_gatt_write_charac_descriptor(connection_handle, tx_handle+2, 2, client_char_conf_data)==BLE_STATUS_NOT_ALLOWED){ //TX_HANDLE;
    532                      // Radio is busy.
    533                      if(Timer_Expired(&t)) break;
    534                  }
    535                  APP_FLAG_SET(NOTIFICATIONS_ENABLED);
    536                }
    537              else if(APP_FLAG(CONNECTED) && APP_FLAG(END_READ_TX_CHAR_HANDLE) && APP_FLAG(END_READ_RX_CHAR_HANDLE) && APP_FLAG(NOTIFICATIONS_ENABLED)){
    538                uint8_t data_buffer[] = {0x48,0x45,0x4c,0x4c,0x4f,0x0d};
    539                uint16_t Nb_bytes = 6;
    540                processInputData(data_buffer, Nb_bytes);
    541                Clock_Wait(1000);
    542                }
    543             
    544          #endif
    545              
    546              
    547          #if THROUGHPUT_TEST && SERVER
    548              
    549              
    550              static uint8_t test_done = FALSE;
    551              
    552              if(APP_FLAG(CONNECTED) && !test_done && APP_FLAG(NOTIFICATIONS_ENABLED)){
    553              
    554                  uint8_t data[20] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J'};
    555                  
    556                  static tClockTime time, time2;
    557                  time = Clock_Time();
    558                  
    559                  for(int i = 0; i < NUM_PACKETS; i++){
    560                      
    561                      struct timer t;
    562                      Timer_Set(&t, CLOCK_SECOND*10);
    563                                      
    564                      while(aci_gatt_update_char_value(chatServHandle, TXCharHandle, 0, 20, data)==BLE_STATUS_INSUFFICIENT_RESOURCES)
    565                      {
    566                        // Radio is busy (buffer full).
    567                        if(Timer_Expired(&t))
    568                            break;
    569                      }
    570                  
    571                  }
    572                  
    573                  time2 = Clock_Time();
    574                  tClockTime diff = time2-time;
    575                  printf("\n%d packets. Elapsed time: %d ms. App throughput: %.2f kbps.\n\r", NUM_PACKETS, diff, (float)NUM_PACKETS*20*8/diff);
    576                  
    577                  test_done = TRUE;
    578              }
    579          #endif
    580              
    581          }
    582          
    583          /**
    584            * @brief  This function is called whenever there is an ACI event to be processed.
    585            * @note   Inside this function each event must be identified and correctly
    586            *         parsed.
    587            * @param  pckt  Pointer to the ACI packet
    588            * @retval None
    589            */
    590          void HCI_Event_CB(void *pckt)
    591          {
    592              hci_uart_pckt *hci_pckt = pckt;
    593              hci_event_pckt *event_pckt = (hci_event_pckt*)hci_pckt->data;
    594              
    595              if(hci_pckt->type != HCI_EVENT_PKT)
    596                  return;
    597              
    598              switch(event_pckt->evt){
    599                  
    600              case EVT_DISCONN_COMPLETE:
    601                  {
    602                      GAP_DisconnectionComplete_CB();
    603                  }
    604                  break;
    605                  
    606              case EVT_LE_META_EVENT:
    607                  {
    608                      evt_le_meta_event *evt = (void *)event_pckt->data;
    609                      
    610                      switch(evt->subevent){
    611                      case EVT_LE_CONN_COMPLETE:
    612                          {
    613                              evt_le_connection_complete *cc = (void *)evt->data;
    614                              GAP_ConnectionComplete_CB(cc->peer_bdaddr, cc->handle);
    615                          }
    616                          break;
    617                      }
    618                  }
    619                  break;
    620                  
    621              case EVT_VENDOR:
    622                  {
    623                      evt_blue_aci *blue_evt = (void*)event_pckt->data;
    624                      switch(blue_evt->ecode){
    625                          
    626                      case EVT_BLUE_GATT_ATTRIBUTE_MODIFIED:
    627                          {
    628                              evt_gatt_attr_modified *evt = (evt_gatt_attr_modified*)blue_evt->data;
    629                              Attribute_Modified_CB(evt->attr_handle, evt->data_length, evt->att_data);
    630                              
    631                              //Catch event
    632                              GPIO_ToggleBits(GPIOC,LED0);
    633                              uint16_t defined_hex = 0x45;
    634                              uint16_t handle = evt->attr_handle;
    635                              uint8_t data_length = evt->data_length;
    636                              uint8_t *att_data = evt->att_data;
    637                              if(handle == RXCharHandle + 1){
    638                                if(att_data[0] == defined_hex){
    639                                  // call function
    640                                   startTimer(2);
    641                                 }
    642                                 //Clock_Wait(100);
    643                                 //att_data[0] = att_data[0]+1;
    644                                 //processInputData(att_data, data_length);
    645                              }
    646                              
    647                          }
    648                          break;
    649                      case EVT_BLUE_GATT_NOTIFICATION:
    650                          {
    651                              evt_gatt_attr_notification *evt = (evt_gatt_attr_notification*)blue_evt->data;
    652                              GATT_Notification_CB(evt->attr_handle, evt->event_data_length - 2, evt->attr_value);
    653                          }
    654                          break;
    655                       case EVT_BLUE_L2CAP_CONN_UPD_RESP:
    656                          {
    657                              evt_l2cap_conn_upd_resp *resp = (void*)blue_evt->data;
    658                              if(resp->result){
    659                                  PRINTF("> Connection parameters rejected.\n");
    660                              }
    661                              else{
    662                                  PRINTF("> Connection parameters accepted.\n");
    663                              }
    664                          }
    665                          break;
    666          #ifdef CLIENT            
    667                        case EVT_BLUE_GATT_DISC_READ_CHAR_BY_UUID_RESP:
    668                          {
    669                              evt_gatt_disc_read_char_by_uuid_resp *resp = (void*)blue_evt->data;
    670                              
    671                              if (APP_FLAG(START_READ_TX_CHAR_HANDLE) && !APP_FLAG(END_READ_TX_CHAR_HANDLE))
    672                              {
    673                                tx_handle = resp->attr_handle;
    674                                PRINTF("TX Char Handle %04X\n\r", tx_handle);
    675                              }
    676                              else if (APP_FLAG(START_READ_RX_CHAR_HANDLE) && !APP_FLAG(END_READ_RX_CHAR_HANDLE))
    677                              {
    678                                rx_handle = resp->attr_handle;
    679                                PRINTF("RX Char Handle %04X\n\r", rx_handle);
    680                              }
    681                          }
    682                          break;  
    683                          
    684                          case EVT_BLUE_GATT_PROCEDURE_COMPLETE:
    685                          {
    686                            /* Wait for gatt procedure complete event trigger related to Discovery Charac by UUID */
    687                            //evt_gatt_procedure_complete *pr = (void*)blue_evt->data;
    688                            
    689                            if (APP_FLAG(START_READ_TX_CHAR_HANDLE) && !APP_FLAG(END_READ_TX_CHAR_HANDLE))
    690                            {
    691                              APP_FLAG_SET(END_READ_TX_CHAR_HANDLE);
    692                            }
    693                            else if (APP_FLAG(START_READ_RX_CHAR_HANDLE) && !APP_FLAG(END_READ_RX_CHAR_HANDLE))
    694                            {
    695                              APP_FLAG_SET(END_READ_RX_CHAR_HANDLE);
    696                            }
    697                          }
    698                          break;
    699          #endif         
    700                      }
    701                  }
    702                  break;
    703              }
    704              
    705          }
    706          
    707          
    708          #ifdef USE_FULL_ASSERT
    709          /*******************************************************************************
    710          * Function Name  : assert_failed
    711          * Description    : Reports the name of the source file and the source line number
    712          *                  where the assert_param error has occurred.
    713          * Input          : - file: pointer to the source file name
    714          *                  - line: assert_param error line source number
    715          * Output         : None
    716          * Return         : None
    717          *******************************************************************************/
    718          void assert_failed(uint8_t* file, uint32_t line)
    719          {
    720              /* User can add his own implementation to report the file name and line number,
    721              ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
    722              
    723              /* Infinite loop */
    724              while (1)
    725              {
    726                printf("\r\nFailed\r\n");
    727                Clock_Wait(10000);
    728              }
    729          }
    730          #endif
    731          
    732          /******************* (C) COPYRIGHT 2014 STMicroelectronics *****END OF FILE****/
    733          /** \endcond
    734           */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   GAP_ConnectionComplete_CB
         0   -> printf
        16   -> printf
        16   -> turnLED
       8   GAP_DisconnectionComplete_CB
         8   -> printf
         8   -> turnLED
       0   GATT_Notification_CB
       8   HCI_Event_CB
         8   -> Attribute_Modified_CB
         0   -> GAP_ConnectionComplete_CB
         0   -> GAP_DisconnectionComplete_CB
         8   -> GPIO_ToggleBits
         0   -> printf
         0   -> startTimer
      56   Make_Connection
        56   -> aci_gap_set_discoverable
        56   -> printf
      64   User_Process
        64   -> aci_gap_set_discoverable
        64   -> printf
      64   main
        64   -> Add_Chat_Service
        64   -> BlueNRG_RST
        64   -> Clock_Init
        64   -> Clock_Wait
        64   -> FLASH_SLEEPPowerDownCmd
        64   -> HCI_Init
        64   -> HCI_Process
        64   -> Init_GPIOs
        64   -> NVIC_PriorityGroupConfig
        64   -> NVIC_SetVectorTable
        64   -> PWR_FastWakeUpCmd
        64   -> PWR_PVDCmd
        64   -> PWR_UltraLowPowerCmd
        64   -> RCC_Configuration
        64   -> SdkEvalGetVersion
        64   -> SdkEvalIdentification
        64   -> SdkEvalSpiInit
        64   -> SdkEval_IO_Config
        64   -> aci_gap_init
        64   -> aci_gap_set_discoverable
        64   -> aci_gatt_init
        64   -> aci_gatt_update_char_value
        64   -> aci_hal_set_tx_power_level
        64   -> aci_hal_write_config_data
        64   -> enableTimerInterrupt
        64   -> initLED
        64   -> initTimer
        64   -> printf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable23_4
       2  ?_0
      28  ?_1
       8  ?_10
      24  ?_11
       8  ?_12
       8  ?_13
      16  ?_14
      36  ?_15
      36  ?_16
       8  ?_17
      16  ?_18
      20  ?_2
      12  ?_3
      36  ?_4
      20  ?_5
      48  ?_6
      32  ?_7
      32  ?_8
      28  ?_9
      94  GAP_ConnectionComplete_CB
      78  GAP_DisconnectionComplete_CB
       2  GATT_Notification_CB
     148  HCI_Event_CB
      76  Make_Connection
      92  User_Process
       8  connection_handle
          app_flags
       8  l2cap_req_timer
     416  main

 
     8 bytes in section .bss
     8 bytes in section .data
     2 bytes in section .rodata
 1 342 bytes in section .text
 
 1 342 bytes of CODE  memory
     2 bytes of CONST memory
    16 bytes of DATA  memory

Errors: none
Warnings: 2
