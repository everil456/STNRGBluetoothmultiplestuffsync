###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        06/Mar/2015  09:03:52
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Bluetooth LE\SimpleBlueNRG_HCI\hci\hci.c
#    Command line =  
#        "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Bluetooth LE\SimpleBlueNRG_HCI\hci\hci.c" -D USE_STDPERIPH_DRIVER
#        -D STM32L1XX_MD -D SYSCLK_FREQ_HSI_32MHz -D ENABLE_USB -D
#        ENABLE_USB_PRINTF -D CLIENT=1 -lcN "C:\School\2014 Fall\ECE
#        4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\Client\List\" --diag_suppress Pa050
#        -o "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\Client\Obj\" --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "C:\School\2014 Fall\ECE
#        4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\inc\" -I "C:\School\2014 Fall\ECE
#        4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\Bluetooth
#        LE\SimpleBlueNRG_HCI\" -I "C:\School\2014 Fall\ECE 4900\Bluetooth
#        Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\Bluetooth
#        LE\SimpleBlueNRG_HCI\includes\" -I "C:\School\2014 Fall\ECE
#        4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\" -I
#        "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32_USB-FS-Device_Driver\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32L1xx_StdPeriph_Driver\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\I2C\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\LIS3DH\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\STLM75\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\HTS221\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\LPS25H\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\SDK_Eval_STM32L\inc\"
#        -Ohs --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\Client\List\hci.lst
#    Object file  =  
#        C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\Client\Obj\hci.o
#
###############################################################################

C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects V2\Bluetooth LE\SimpleBlueNRG_HCI\hci\hci.c
      1          /**
      2            ******************************************************************************
      3            * @file    hci.c 
      4            * @author  AMS/HESA Application Team
      5            * @brief   Function for managing HCI interface.
      6            ******************************************************************************
      7            *
      8            *
      9            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     10            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     11            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     12            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     13            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     14            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     15            *
     16            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
     17            */ 
     18          
     19          #include "hal_types.h"
     20          #include "osal.h"
     21          #include "ble_status.h"
     22          #include "hal.h"
     23          #include "hci_const.h"
     24          #include "gp_timer.h"
     25          #include "low_power.h"
     26          #include <stdio.h>
     27          
     28          #if BLE_CONFIG_DBG_ENABLE
     29          #define PRINTF(...) printf(__VA_ARGS__)
     30          #else
     31          #define PRINTF(...)
     32          #endif
     33          
     34          #define HCI_LOG_ON 0
     35          
     36          #define HCI_READ_PACKET_NUM_MAX 		 (5)
     37          
     38          #define MIN(a,b)            ((a) < (b) )? (a) : (b)
     39          #define MAX(a,b)            ((a) > (b) )? (a) : (b)
     40          
     41          static void enqueue_packet(tHciDataPacket * hciReadPacket);
     42          
     43          tListNode hciReadPktPool;
     44          tListNode hciReadPktRxQueue;
     45          /* pool of hci read packets */
     46          static tHciDataPacket     hciReadPacketBuffer[HCI_READ_PACKET_NUM_MAX];
     47          
     48          static uint8_t *hci_buffer = NULL;
     49          static volatile uint16_t hci_pckt_len;
     50          
     51          volatile uint8_t readPacketListFull=FALSE;
     52          
     53          void HCI_Init(void)
     54          {
     55            uint8_t index;
     56            
     57            /* Initialize list heads of ready and free hci data packet queues */
     58            list_init_head (&hciReadPktPool);
     59            list_init_head (&hciReadPktRxQueue);
     60            
     61            /* Initialize the queue of free hci data packets */
     62            for (index = 0; index < HCI_READ_PACKET_NUM_MAX; index++)
     63            {
     64              list_insert_tail(&hciReadPktPool, (tListNode *)&hciReadPacketBuffer[index]);
     65            }
     66          }
     67          
     68          static volatile hci_packet_complete_callback packet_complete_callback = NULL;
     69          
     70          static void hci_set_packet_complete_callback(hci_packet_complete_callback cb)
     71          {
     72            packet_complete_callback = cb;
     73          }
     74          
     75          void HCI_Input(tHciDataPacket * hciReadPacket)
     76          {
     77            uint8_t byte;
     78            hci_acl_hdr *acl_hdr;
     79            
     80            static hci_state state = WAITING_TYPE;
     81            
     82            uint16_t collected_payload_len = 0;
     83            uint16_t payload_len;
     84            
     85            hci_buffer = hciReadPacket->dataBuff;
     86            
     87            if(state == WAITING_TYPE)
     88              hci_pckt_len = 0;
     89            
     90            while(hci_pckt_len < HCI_PACKET_SIZE){
     91              
     92              byte = hci_buffer[hci_pckt_len++];
     93              
     94              if(state == WAITING_TYPE){
     95                /* Only ACL Data and Events packets are accepted. */
     96                if(byte == HCI_EVENT_PKT){
     97                  state = WAITING_EVENT_CODE;
     98                }
     99                //            else if(byte == HCI_ACLDATA_PKT){
    100                //                state = WAITING_HANDLE;
    101                //            }
    102                else{
    103                  /* Incorrect type. Reset state machine. */
    104                  state = WAITING_TYPE;
    105                  break;
    106                }
    107              }
    108              else if(state == WAITING_EVENT_CODE)
    109                state = WAITING_PARAM_LEN;
    110              else if(state == WAITING_HANDLE)
    111                state = WAITING_HANDLE_FLAG;
    112              else if(state == WAITING_HANDLE_FLAG)
    113                state = WAITING_DATA_LEN1;
    114              else if(state == WAITING_DATA_LEN1)
    115                state = WAITING_DATA_LEN2;
    116              
    117              else if(state == WAITING_DATA_LEN2){
    118                acl_hdr = (void *)&hci_buffer[HCI_HDR_SIZE];
    119                payload_len = acl_hdr->dlen;
    120                collected_payload_len = 0;
    121                state = WAITING_PAYLOAD;
    122              }
    123              else if(state == WAITING_PARAM_LEN){
    124                payload_len = byte;
    125                collected_payload_len = 0;
    126                state = WAITING_PAYLOAD;
    127              }
    128              else if(state == WAITING_PAYLOAD){
    129                collected_payload_len += 1;
    130                if(collected_payload_len >= payload_len){
    131                  /* Reset state machine. */
    132                  state = WAITING_TYPE;
    133                  enqueue_packet(hciReadPacket);
    134                  
    135                  if(packet_complete_callback){
    136                    uint16_t len = hci_pckt_len;
    137                    packet_complete_callback(hci_buffer, len);
    138                  }
    139                  break;
    140                }
    141              }
    142            }        
    143          }
    144          
    145          void enqueue_packet(tHciDataPacket * hciReadPacket)
    146          {
    147            hci_uart_pckt *hci_pckt = (void*)hciReadPacket->dataBuff;
    148            hci_event_pckt *event_pckt = (void*)hci_pckt->data;
    149            
    150            // Do not enqueue Command Complete or Command Status events
    151            
    152            if((hci_pckt->type != HCI_EVENT_PKT) ||
    153               event_pckt->evt == EVT_CMD_COMPLETE ||
    154                 event_pckt->evt == EVT_CMD_STATUS){
    155                   // Insert the packet back into the pool.
    156                   list_insert_tail(&hciReadPktPool, (tListNode *)hciReadPacket);
    157                 }
    158            else {    
    159              // Insert the packet into the queue of events to be processed.
    160              list_insert_tail(&hciReadPktRxQueue, (tListNode *)hciReadPacket);
    161            }
    162          }
    163          
    164          void HCI_Process(void)
    165          {
    166            uint8_t data_len;
    167            uint8_t buffer[HCI_PACKET_SIZE];
    168            tHciDataPacket * hciReadPacket = NULL;
    169            
    170            Disable_SPI_IRQ();
    171            uint8_t list_empty = list_is_empty(&hciReadPktRxQueue);        
    172            /* process any pending events read */
    173            while(list_empty == FALSE)
    174            {
    175              list_remove_head (&hciReadPktRxQueue, (tListNode **)&hciReadPacket);
    176              Enable_SPI_IRQ();
    177              HCI_Event_CB(hciReadPacket->dataBuff);
    178              Disable_SPI_IRQ();
    179              list_insert_tail(&hciReadPktPool, (tListNode *)hciReadPacket);
    180              list_empty = list_is_empty(&hciReadPktRxQueue);
    181            }
    182            if (readPacketListFull) {
    183              while(BlueNRG_DataPresent()) {
    184                data_len = BlueNRG_SPI_Read_All(buffer, HCI_PACKET_SIZE);
    185                if(data_len > 0)
    186                  HCI_Event_CB(buffer);
    187              }
    188              readPacketListFull = FALSE;
    189            }
    190            
    191            Enable_SPI_IRQ();
    192          }
    193          
    194          BOOL HCI_Queue_Empty(void)
    195          {
    196            return list_is_empty(&hciReadPktRxQueue);
    197          }
    198          
    199          void HCI_Isr(void)
    200          {
    201            tHciDataPacket * hciReadPacket = NULL;
    202            uint8_t data_len;
    203            
    204            Clear_SPI_EXTI_Flag();
    205            while(SdkEvalSPI_Irq_Pin()){        
    206              if (list_is_empty (&hciReadPktPool) == FALSE){
    207                
    208                /* enqueueing a packet for read */
    209                list_remove_head (&hciReadPktPool, (tListNode **)&hciReadPacket);
    210                
    211                data_len = BlueNRG_SPI_Read_All(hciReadPacket->dataBuff,HCI_PACKET_SIZE);
    212                if(data_len > 0){                    
    213                  HCI_Input(hciReadPacket);
    214                  // Packet will be inserted to te correct queue by 
    215                }
    216                else {
    217                  // Insert the packet back into the pool.
    218                  list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket);
    219                }
    220                
    221              }
    222              else{
    223                // HCI Read Packet Pool is empty, wait for a free packet.
    224                readPacketListFull = TRUE;
    225                Clear_SPI_EXTI_Flag();
    226                return;
    227              }
    228              
    229              Clear_SPI_EXTI_Flag();
    230            }
    231          }
    232          
    233          void hci_write(const void* data1, const void* data2, uint16_t n_bytes1, uint16_t n_bytes2){
    234          #if  HCI_LOG_ON
    235            PRINTF("HCI <- ");
    236            for(int i=0; i < n_bytes1; i++)
    237              PRINTF("%02X ", *((uint8_t*)data1 + i));
    238            for(int i=0; i < n_bytes2; i++)
    239              PRINTF("%02X ", *((uint8_t*)data2 + i));
    240            PRINTF("\n");    
    241          #endif
    242            
    243            Hal_Write_Serial(data1, data2, n_bytes1, n_bytes2);
    244          }
    245          
    246          int hci_send_cmd(uint16_t ogf, uint16_t ocf, uint8_t plen, void *param)
    247          {
    248            hci_command_hdr hc;
    249            
    250            hc.opcode = htobs(cmd_opcode_pack(ogf, ocf));
    251            hc.plen= plen;
    252            
    253            uint8_t header[HCI_HDR_SIZE + HCI_COMMAND_HDR_SIZE];
    254            header[0] = HCI_COMMAND_PKT;
    255            Osal_MemCpy(header+1, &hc, sizeof(hc));
    256            
    257            hci_write(header, param, sizeof(header), plen);
    258            
    259            return 0;
    260          }
    261          
    262          static uint8_t new_packet;
    263          
    264          void new_hci_event(void *pckt, uint16_t len)
    265          {
    266            Disable_SPI_IRQ(); /* Must be re-enabled after packet processing. */
    267            
    268            new_packet = TRUE;
    269          }
    270          
    271          /* 'to' is timeout in system clock ticks.  */
    272          int hci_send_req(struct hci_request *r, BOOL async)
    273          {
    274            uint8_t *ptr;
    275            uint16_t opcode = htobs(cmd_opcode_pack(r->ogf, r->ocf));
    276            hci_event_pckt *event_pckt;
    277            hci_uart_pckt *hci_hdr;
    278            int to = DEFAULT_TIMEOUT;
    279            struct timer t;
    280            
    281            new_packet = FALSE;
    282            hci_set_packet_complete_callback(new_hci_event);
    283            if (hci_send_cmd(r->ogf, r->ocf, r->clen, r->cparam) < 0)
    284              goto failed;
    285            
    286            if(async){
    287              goto done;
    288            }
    289            
    290            /* Minimum timeout is 1. */
    291            if(to == 0)
    292              to = 1;
    293            
    294            Timer_Set(&t, to);
    295            
    296            while(1) {
    297              evt_cmd_complete *cc;
    298              evt_cmd_status *cs;
    299              evt_le_meta_event *me;
    300              int len;
    301                
    302              while(1){
    303                if(Timer_Expired(&t)){
    304                  goto failed;
    305                }
    306                if(new_packet){
    307                  break;
    308                }
    309              }
    310              
    311              hci_hdr = (void *)hci_buffer;
    312              if(hci_hdr->type != HCI_EVENT_PKT){
    313                new_packet = FALSE;
    314                Enable_SPI_IRQ();
    315                continue;
    316              }
    317              
    318              event_pckt = (void *) (hci_hdr->data);
    319              
    320              ptr = hci_buffer + (1 + HCI_EVENT_HDR_SIZE);
    321              len = hci_pckt_len - (1 + HCI_EVENT_HDR_SIZE);
    322              
    323              switch (event_pckt->evt) {
    324                
    325              case EVT_CMD_STATUS:
    326                cs = (void *) ptr;
    327                
    328                if (cs->opcode != opcode)
    329                  break;
    330                
    331                if (r->event != EVT_CMD_STATUS) {
    332                  if (cs->status) {
    333                    goto failed;
    334                  }
    335                  break;
    336                }
    337                
    338                r->rlen = MIN(len, r->rlen);
    339                Osal_MemCpy(r->rparam, ptr, r->rlen);
    340                goto done;
    341                
    342              case EVT_CMD_COMPLETE:
    343                cc = (void *) ptr;
    344                
    345                if (cc->opcode != opcode)
    346                  break;
    347                
    348                ptr += EVT_CMD_COMPLETE_SIZE;
    349                len -= EVT_CMD_COMPLETE_SIZE;
    350                
    351                r->rlen = MIN(len, r->rlen);
    352                Osal_MemCpy(r->rparam, ptr, r->rlen);
    353                goto done;
    354                
    355              case EVT_LE_META_EVENT:
    356                me = (void *) ptr;
    357                
    358                if (me->subevent != r->event)
    359                  break;
    360                
    361                len -= 1;
    362                r->rlen = MIN(len, r->rlen);
    363                Osal_MemCpy(r->rparam, me->data, r->rlen);
    364                goto done;
    365                
    366              case EVT_HARDWARE_ERROR:            
    367                goto failed;
    368                
    369              default:
    370                break; // In the meantime there could be other events from the controller.
    371              }
    372              
    373              new_packet = FALSE;
    374              Enable_SPI_IRQ();
    375              
    376            }
    377            
    378          failed:
    379            hci_set_packet_complete_callback(NULL);
    380            Enable_SPI_IRQ();
    381            return -1;
    382            
    383          done:
    384            hci_set_packet_complete_callback(NULL);
    385            Enable_SPI_IRQ();
    386            return 0;
    387          }
    388          
    389          int hci_reset()
    390          {
    391            struct hci_request rq;
    392            uint8_t status;
    393            
    394            Osal_MemSet(&rq, 0, sizeof(rq));
    395            rq.ogf = OGF_HOST_CTL;
    396            rq.ocf = OCF_RESET;
    397            rq.rparam = &status;
    398            rq.rlen = 1;
    399            
    400            if (hci_send_req(&rq, FALSE) < 0)
    401              return BLE_STATUS_TIMEOUT;
    402            
    403            return status;  
    404          }
    405          
    406          int hci_disconnect(uint16_t	handle, uint8_t reason)
    407          {
    408            struct hci_request rq;
    409            disconnect_cp cp;
    410            uint8_t status;
    411            
    412            cp.handle = handle;
    413            cp.reason = reason;
    414            
    415            Osal_MemSet(&rq, 0, sizeof(rq));
    416            rq.ogf = OGF_LINK_CTL;
    417            rq.ocf = OCF_DISCONNECT;
    418            rq.cparam = &cp;
    419            rq.clen = DISCONNECT_CP_SIZE;
    420            rq.event = EVT_CMD_STATUS;
    421            rq.rparam = &status;
    422            rq.rlen = 1;
    423            
    424            if (hci_send_req(&rq, FALSE) < 0)
    425              return BLE_STATUS_TIMEOUT;
    426            
    427            return status;  
    428          }
    429          
    430          int hci_le_read_local_version(uint8_t *hci_version, uint16_t *hci_revision, uint8_t *lmp_pal_version, 
    431                                        uint16_t *manufacturer_name, uint16_t *lmp_pal_subversion)
    432          {
    433            struct hci_request rq;
    434            read_local_version_rp resp;
    435            
    436            Osal_MemSet(&resp, 0, sizeof(resp));
    437            
    438            Osal_MemSet(&rq, 0, sizeof(rq));
    439            rq.ogf = OGF_INFO_PARAM;
    440            rq.ocf = OCF_READ_LOCAL_VERSION;
    441            rq.cparam = NULL;
    442            rq.clen = 0;
    443            rq.rparam = &resp;
    444            rq.rlen = READ_LOCAL_VERSION_RP_SIZE;
    445            
    446            if (hci_send_req(&rq, FALSE) < 0)
    447              return BLE_STATUS_TIMEOUT;
    448            
    449            if (resp.status) {
    450              return resp.status;
    451            }
    452            
    453            
    454            *hci_version = resp.hci_version;
    455            *hci_revision =  btohs(resp.hci_revision);
    456            *lmp_pal_version = resp.lmp_pal_version;
    457            *manufacturer_name = btohs(resp.manufacturer_name);
    458            *lmp_pal_subversion = btohs(resp.lmp_pal_subversion);
    459            
    460            return 0;
    461          }
    462          
    463          int hci_le_read_buffer_size(uint16_t *pkt_len, uint8_t *max_pkt)
    464          {
    465            struct hci_request rq;
    466            le_read_buffer_size_rp resp;
    467            
    468            Osal_MemSet(&resp, 0, sizeof(resp));
    469            
    470            Osal_MemSet(&rq, 0, sizeof(rq));
    471            rq.ogf = OGF_LE_CTL;
    472            rq.ocf = OCF_LE_READ_BUFFER_SIZE;
    473            rq.cparam = NULL;
    474            rq.clen = 0;
    475            rq.rparam = &resp;
    476            rq.rlen = LE_READ_BUFFER_SIZE_RP_SIZE;
    477            
    478            if (hci_send_req(&rq, FALSE) < 0)
    479              return BLE_STATUS_TIMEOUT;
    480            
    481            if (resp.status) {
    482              return resp.status;
    483            }
    484            
    485            *pkt_len = resp.pkt_len;
    486            *max_pkt = resp.max_pkt;
    487            
    488            return 0;
    489          }
    490          
    491          int hci_le_set_advertising_parameters(uint16_t min_interval, uint16_t max_interval, uint8_t advtype,
    492                                                uint8_t own_bdaddr_type, uint8_t direct_bdaddr_type, const tBDAddr direct_bdaddr, uint8_t chan_map,
    493                                                uint8_t filter)
    494          {
    495            struct hci_request rq;
    496            le_set_adv_parameters_cp adv_cp;
    497            uint8_t status;
    498            
    499            Osal_MemSet(&adv_cp, 0, sizeof(adv_cp));
    500            adv_cp.min_interval = min_interval;
    501            adv_cp.max_interval = max_interval;
    502            adv_cp.advtype = advtype;
    503            adv_cp.own_bdaddr_type = own_bdaddr_type;
    504            adv_cp.direct_bdaddr_type = direct_bdaddr_type;
    505            Osal_MemCpy(adv_cp.direct_bdaddr,direct_bdaddr,sizeof(adv_cp.direct_bdaddr));
    506            adv_cp.chan_map = chan_map;
    507            adv_cp.filter = filter;
    508            
    509            Osal_MemSet(&rq, 0, sizeof(rq));
    510            rq.ogf = OGF_LE_CTL;
    511            rq.ocf = OCF_LE_SET_ADV_PARAMETERS;
    512            rq.cparam = &adv_cp;
    513            rq.clen = LE_SET_ADV_PARAMETERS_CP_SIZE;
    514            rq.rparam = &status;
    515            rq.rlen = 1;
    516            
    517            if (hci_send_req(&rq, FALSE) < 0)
    518              return BLE_STATUS_TIMEOUT;
    519            
    520            return status;
    521          }
    522          
    523          int hci_le_set_advertising_data(uint8_t length, const uint8_t data[])
    524          {
    525            struct hci_request rq;
    526            le_set_adv_data_cp adv_cp;
    527            uint8_t status;
    528            
    529            Osal_MemSet(&adv_cp, 0, sizeof(adv_cp));
    530            adv_cp.length = length;
    531            Osal_MemCpy(adv_cp.data, data, MIN(31,length));
    532            
    533            Osal_MemSet(&rq, 0, sizeof(rq));
    534            rq.ogf = OGF_LE_CTL;
    535            rq.ocf = OCF_LE_SET_ADV_DATA;
    536            rq.cparam = &adv_cp;
    537            rq.clen = LE_SET_ADV_DATA_CP_SIZE;
    538            rq.rparam = &status;
    539            rq.rlen = 1;
    540            
    541            if (hci_send_req(&rq, FALSE) < 0)
    542              return BLE_STATUS_TIMEOUT;
    543            
    544            return status;
    545          }
    546          
    547          int hci_le_set_advertise_enable(uint8_t enable)
    548          {
    549            struct hci_request rq;
    550            le_set_advertise_enable_cp adv_cp;
    551            uint8_t status;
    552            
    553            Osal_MemSet(&adv_cp, 0, sizeof(adv_cp));
    554            adv_cp.enable = enable?1:0;
    555            
    556            Osal_MemSet(&rq, 0, sizeof(rq));
    557            rq.ogf = OGF_LE_CTL;
    558            rq.ocf = OCF_LE_SET_ADVERTISE_ENABLE;
    559            rq.cparam = &adv_cp;
    560            rq.clen = LE_SET_ADVERTISE_ENABLE_CP_SIZE;
    561            rq.rparam = &status;
    562            rq.rlen = 1;
    563            
    564            if (hci_send_req(&rq, FALSE) < 0)
    565              return BLE_STATUS_TIMEOUT;
    566            
    567            return status;
    568          }
    569          
    570          int hci_le_set_scan_parameters(uint8_t	type, uint16_t interval,
    571                                         uint16_t window, uint8_t own_bdaddr_type,
    572                                         uint8_t	filter)
    573          {
    574            struct hci_request rq;
    575            le_set_scan_parameters_cp scan_cp;
    576            uint8_t status;
    577            
    578            Osal_MemSet(&scan_cp, 0, sizeof(scan_cp));
    579            scan_cp.type = type;
    580            scan_cp.interval = interval;
    581            scan_cp.window = window;
    582            scan_cp.own_bdaddr_type = own_bdaddr_type;
    583            scan_cp.filter = filter;
    584            
    585            Osal_MemSet(&rq, 0, sizeof(rq));
    586            rq.ogf = OGF_LE_CTL;
    587            rq.ocf = OCF_LE_SET_SCAN_PARAMETERS;
    588            rq.cparam = &scan_cp;
    589            rq.clen = LE_SET_SCAN_PARAMETERS_CP_SIZE;
    590            rq.rparam = &status;
    591            rq.rlen = 1;
    592            
    593            if (hci_send_req(&rq, FALSE) < 0)
    594              return BLE_STATUS_TIMEOUT;
    595            
    596            return status;
    597          }
    598          
    599          int hci_le_set_scan_enable(uint8_t enable, uint8_t filter_dup)
    600          {
    601            struct hci_request rq;
    602            le_set_scan_enable_cp scan_cp;
    603            uint8_t status;
    604            
    605            Osal_MemSet(&scan_cp, 0, sizeof(scan_cp));
    606            scan_cp.enable = enable?1:0;
    607            scan_cp.filter_dup = filter_dup;
    608            
    609            Osal_MemSet(&rq, 0, sizeof(rq));
    610            rq.ogf = OGF_LE_CTL;
    611            rq.ocf = OCF_LE_SET_SCAN_ENABLE;
    612            rq.cparam = &scan_cp;
    613            rq.clen = LE_SET_SCAN_ENABLE_CP_SIZE;
    614            rq.rparam = &status;
    615            rq.rlen = 1;
    616            
    617            if (hci_send_req(&rq, FALSE) < 0)
    618              return BLE_STATUS_TIMEOUT;
    619            
    620            return status;
    621          }
    622          
    623          int hci_le_rand(uint8_t random_number[8])
    624          {
    625            struct hci_request rq;
    626            le_rand_rp resp;
    627            
    628            Osal_MemSet(&resp, 0, sizeof(resp));
    629            
    630            Osal_MemSet(&rq, 0, sizeof(rq));
    631            rq.ogf = OGF_LE_CTL;
    632            rq.ocf = OCF_LE_RAND;
    633            rq.cparam = NULL;
    634            rq.clen = 0;
    635            rq.rparam = &resp;
    636            rq.rlen = LE_RAND_RP_SIZE;
    637            
    638            if (hci_send_req(&rq, FALSE) < 0)
    639              return BLE_STATUS_TIMEOUT;
    640            
    641            if (resp.status) {
    642              return resp.status;
    643            }
    644            
    645            Osal_MemCpy(random_number, resp.random, 8);
    646            
    647            return 0;
    648          }
    649          
    650          int hci_le_set_scan_resp_data(uint8_t length, const uint8_t data[])
    651          {
    652            struct hci_request rq;
    653            le_set_scan_response_data_cp scan_resp_cp;
    654            uint8_t status;
    655            
    656            Osal_MemSet(&scan_resp_cp, 0, sizeof(scan_resp_cp));
    657            scan_resp_cp.length = length;
    658            Osal_MemCpy(scan_resp_cp.data, data, MIN(31,length));
    659            
    660            Osal_MemSet(&rq, 0, sizeof(rq));
    661            rq.ogf = OGF_LE_CTL;
    662            rq.ocf = OCF_LE_SET_SCAN_RESPONSE_DATA;
    663            rq.cparam = &scan_resp_cp;
    664            rq.clen = LE_SET_SCAN_RESPONSE_DATA_CP_SIZE;
    665            rq.rparam = &status;
    666            rq.rlen = 1;
    667            
    668            if (hci_send_req(&rq, FALSE) < 0)
    669              return BLE_STATUS_TIMEOUT;
    670            
    671            return status;
    672          }
    673          
    674          int hci_le_read_advertising_channel_tx_power(int8_t *tx_power_level)
    675          {
    676            struct hci_request rq;
    677            le_read_adv_channel_tx_power_rp resp;
    678            
    679            Osal_MemSet(&resp, 0, sizeof(resp));
    680            
    681            Osal_MemSet(&rq, 0, sizeof(rq));
    682            rq.ogf = OGF_LE_CTL;
    683            rq.ocf = OCF_LE_READ_ADV_CHANNEL_TX_POWER;
    684            rq.cparam = NULL;
    685            rq.clen = 0;
    686            rq.rparam = &resp;
    687            rq.rlen = LE_RAND_RP_SIZE;
    688            
    689            if (hci_send_req(&rq, FALSE) < 0)
    690              return BLE_STATUS_TIMEOUT;
    691            
    692            if (resp.status) {
    693              return resp.status;
    694            }
    695            
    696            *tx_power_level = resp.level;
    697            
    698            return 0;
    699          }
    700          
    701          int hci_le_set_random_address(tBDAddr bdaddr)
    702          {
    703            struct hci_request rq;
    704            le_set_random_address_cp set_rand_addr_cp;
    705            uint8_t status;
    706            
    707            Osal_MemSet(&set_rand_addr_cp, 0, sizeof(set_rand_addr_cp));
    708            Osal_MemCpy(set_rand_addr_cp.bdaddr, bdaddr, sizeof(tBDAddr));
    709            
    710            Osal_MemSet(&rq, 0, sizeof(rq));
    711            rq.ogf = OGF_LE_CTL;
    712            rq.ocf = OCF_LE_SET_RANDOM_ADDRESS;
    713            rq.cparam = &set_rand_addr_cp;
    714            rq.clen = LE_SET_RANDOM_ADDRESS_CP_SIZE;
    715            rq.rparam = &status;
    716            rq.rlen = 1;
    717            
    718            if (hci_send_req(&rq, FALSE) < 0)
    719              return BLE_STATUS_TIMEOUT;
    720            
    721            return status;
    722          }
    723          
    724          int hci_read_bd_addr(tBDAddr bdaddr)
    725          {
    726            struct hci_request rq;
    727            read_bd_addr_rp resp;
    728            
    729            Osal_MemSet(&resp, 0, sizeof(resp));
    730            
    731            Osal_MemSet(&rq, 0, sizeof(rq));
    732            rq.ogf = OGF_INFO_PARAM;
    733            rq.ocf = OCF_READ_BD_ADDR;
    734            rq.cparam = NULL;
    735            rq.clen = 0;
    736            rq.rparam = &resp;
    737            rq.rlen = READ_BD_ADDR_RP_SIZE;
    738            
    739            if (hci_send_req(&rq, FALSE) < 0)
    740              return BLE_STATUS_TIMEOUT;
    741            
    742            if (resp.status) {
    743              return resp.status;
    744            }
    745            Osal_MemCpy(bdaddr, resp.bdaddr, sizeof(tBDAddr));
    746            
    747            return 0;
    748          }
    749          
    750          int hci_le_create_connection(uint16_t interval,	uint16_t window, uint8_t initiator_filter, uint8_t peer_bdaddr_type,
    751                                       const tBDAddr peer_bdaddr,	uint8_t	own_bdaddr_type, uint16_t min_interval,	uint16_t max_interval,
    752                                       uint16_t latency,	uint16_t supervision_timeout, uint16_t min_ce_length, uint16_t max_ce_length)
    753          {
    754            struct hci_request rq;
    755            le_create_connection_cp create_cp;
    756            uint8_t status;
    757            
    758            Osal_MemSet(&create_cp, 0, sizeof(create_cp));
    759            create_cp.interval = interval;
    760            create_cp.window =  window;
    761            create_cp.initiator_filter = initiator_filter;
    762            create_cp.peer_bdaddr_type = peer_bdaddr_type;
    763            Osal_MemCpy(create_cp.peer_bdaddr, peer_bdaddr, sizeof(tBDAddr));
    764            create_cp.own_bdaddr_type = own_bdaddr_type;
    765            create_cp.min_interval=min_interval;
    766            create_cp.max_interval=max_interval;
    767            create_cp.latency = latency;
    768            create_cp.supervision_timeout=supervision_timeout;
    769            create_cp.min_ce_length=min_ce_length;
    770            create_cp.max_ce_length=max_ce_length;
    771            
    772            Osal_MemSet(&rq, 0, sizeof(rq));
    773            rq.ogf = OGF_LE_CTL;
    774            rq.ocf = OCF_LE_CREATE_CONN;
    775            rq.cparam = &create_cp;
    776            rq.clen = LE_CREATE_CONN_CP_SIZE;
    777            rq.event = EVT_CMD_STATUS;
    778            rq.rparam = &status;
    779            rq.rlen = 1;
    780            
    781            if (hci_send_req(&rq, FALSE) < 0)
    782              return BLE_STATUS_TIMEOUT;
    783            
    784            return status;
    785          }
    786          
    787          int hci_le_encrypt(uint8_t key[16], uint8_t plaintextData[16], uint8_t encryptedData[16])
    788          {
    789            struct hci_request rq;
    790            le_encrypt_cp params;
    791            le_encrypt_rp resp;
    792            
    793            Osal_MemSet(&resp, 0, sizeof(resp));
    794            
    795            Osal_MemCpy(params.key, key, 16);
    796            Osal_MemCpy(params.plaintext, plaintextData, 16);
    797            
    798            Osal_MemSet(&rq, 0, sizeof(rq));
    799            rq.ogf = OGF_LE_CTL;
    800            rq.ocf = OCF_LE_ENCRYPT;
    801            rq.cparam = &params;
    802            rq.clen = LE_ENCRYPT_CP_SIZE;
    803            rq.rparam = &resp;
    804            rq.rlen = LE_ENCRYPT_RP_SIZE;
    805            
    806            if (hci_send_req(&rq, FALSE) < 0){
    807              return BLE_STATUS_TIMEOUT;
    808            }
    809            
    810            if (resp.status) {
    811              return resp.status;
    812            }
    813            
    814            Osal_MemCpy(encryptedData, resp.encdata, 16);
    815            
    816            return 0;
    817          }
    818          
    819          int hci_le_ltk_request_reply(uint8_t key[16])
    820          {
    821            struct hci_request rq;
    822            le_ltk_reply_cp params;
    823            le_ltk_reply_rp resp;
    824            
    825            Osal_MemSet(&resp, 0, sizeof(resp));
    826            
    827            params.handle = 1;
    828            Osal_MemCpy(params.key, key, 16);
    829            
    830            Osal_MemSet(&rq, 0, sizeof(rq));
    831            rq.ogf = OGF_LE_CTL;
    832            rq.ocf = OCF_LE_LTK_REPLY;
    833            rq.cparam = &params;
    834            rq.clen = LE_LTK_REPLY_CP_SIZE;
    835            rq.rparam = &resp;
    836            rq.rlen = LE_LTK_REPLY_RP_SIZE;
    837            
    838            if (hci_send_req(&rq, FALSE) < 0)
    839              return BLE_STATUS_TIMEOUT;
    840            
    841            return resp.status;
    842          }
    843          
    844          int hci_le_ltk_request_neg_reply()
    845          {
    846            struct hci_request rq;
    847            le_ltk_neg_reply_cp params;
    848            le_ltk_neg_reply_rp resp;
    849            
    850            Osal_MemSet(&resp, 0, sizeof(resp));
    851            
    852            params.handle = 1;
    853            
    854            Osal_MemSet(&rq, 0, sizeof(rq));
    855            rq.ogf = OGF_LE_CTL;
    856            rq.ocf = OCF_LE_LTK_NEG_REPLY;
    857            rq.cparam = &params;
    858            rq.clen = LE_LTK_NEG_REPLY_CP_SIZE;
    859            rq.rparam = &resp;
    860            rq.rlen = LE_LTK_NEG_REPLY_RP_SIZE;
    861            
    862            if (hci_send_req(&rq, FALSE) < 0)
    863              return BLE_STATUS_TIMEOUT;
    864            
    865            return resp.status;
    866          }
    867          
    868          int hci_le_read_white_list_size(uint8_t *size)
    869          {
    870            struct hci_request rq;
    871            le_read_white_list_size_rp resp;
    872            
    873            Osal_MemSet(&resp, 0, sizeof(resp));
    874            
    875            Osal_MemSet(&rq, 0, sizeof(rq));
    876            rq.ogf = OGF_LE_CTL;
    877            rq.ocf = OCF_LE_READ_WHITE_LIST_SIZE;
    878            rq.rparam = &resp;
    879            rq.rlen = LE_READ_WHITE_LIST_SIZE_RP_SIZE;
    880            
    881            if (hci_send_req(&rq, FALSE) < 0){
    882              return BLE_STATUS_TIMEOUT;
    883            }
    884            
    885            if (resp.status) {
    886              return resp.status;
    887            }
    888            
    889            *size = resp.size;
    890            
    891            return 0;
    892          }
    893          
    894          int hci_le_clear_white_list()
    895          {
    896            struct hci_request rq;
    897            uint8_t status;
    898            
    899            Osal_MemSet(&rq, 0, sizeof(rq));
    900            rq.ogf = OGF_LE_CTL;
    901            rq.ocf = OCF_LE_CLEAR_WHITE_LIST;
    902            rq.rparam = &status;
    903            rq.rlen = 1;
    904            
    905            if (hci_send_req(&rq, FALSE) < 0){
    906              return BLE_STATUS_TIMEOUT;
    907            }
    908            
    909            return status;
    910          }
    911          
    912          int hci_le_add_device_to_white_list(uint8_t	bdaddr_type, tBDAddr bdaddr)
    913          {
    914            struct hci_request rq;
    915            le_add_device_to_white_list_cp params;
    916            uint8_t status;
    917            
    918            params.bdaddr_type = bdaddr_type;
    919            Osal_MemCpy(params.bdaddr, bdaddr, 6);
    920            
    921            Osal_MemSet(&rq, 0, sizeof(rq));
    922            rq.ogf = OGF_LE_CTL;
    923            rq.ocf = OCF_LE_ADD_DEVICE_TO_WHITE_LIST;
    924            rq.cparam = &params;
    925            rq.clen = LE_ADD_DEVICE_TO_WHITE_LIST_CP_SIZE;
    926            rq.rparam = &status;
    927            rq.rlen = 1;
    928            
    929            if (hci_send_req(&rq, FALSE) < 0){
    930              return BLE_STATUS_TIMEOUT;
    931            }
    932            
    933            return status;
    934          }
    935          
    936          int hci_le_remove_device_from_white_list(uint8_t bdaddr_type, tBDAddr bdaddr)
    937          {
    938            struct hci_request rq;
    939            le_remove_device_from_white_list_cp params;
    940            uint8_t status;
    941            
    942            params.bdaddr_type = bdaddr_type;
    943            Osal_MemCpy(params.bdaddr, bdaddr, 6);
    944            
    945            Osal_MemSet(&rq, 0, sizeof(rq));
    946            rq.ogf = OGF_LE_CTL;
    947            rq.ocf = OCF_LE_REMOVE_DEVICE_FROM_WHITE_LIST;
    948            rq.cparam = &params;
    949            rq.clen = LE_REMOVE_DEVICE_FROM_WHITE_LIST_CP_SIZE;
    950            rq.rparam = &status;
    951            rq.rlen = 1;
    952            
    953            if (hci_send_req(&rq, FALSE) < 0){
    954              return BLE_STATUS_TIMEOUT;
    955            }
    956            
    957            return status;
    958          }
    959          
    960          int hci_read_transmit_power_level(uint16_t *conn_handle, uint8_t type, int8_t * tx_level)
    961          {
    962            struct hci_request rq;
    963            read_transmit_power_level_cp params;
    964            read_transmit_power_level_rp resp;
    965            
    966            Osal_MemSet(&resp, 0, sizeof(resp));
    967            
    968            params.handle = *conn_handle;
    969            params.type = type;
    970            
    971            Osal_MemSet(&rq, 0, sizeof(rq));
    972            rq.ogf = OGF_HOST_CTL;
    973            rq.ocf = OCF_READ_TRANSMIT_POWER_LEVEL;
    974            rq.cparam = &params;
    975            rq.clen = READ_TRANSMIT_POWER_LEVEL_CP_SIZE;
    976            rq.rparam = &resp;
    977            rq.rlen = READ_TRANSMIT_POWER_LEVEL_RP_SIZE;
    978            
    979            if (hci_send_req(&rq, FALSE) < 0){
    980              return BLE_STATUS_TIMEOUT;
    981            }
    982            
    983            if (resp.status) {
    984              return resp.status;
    985            }
    986            
    987            *conn_handle = resp.handle;
    988            *tx_level = resp.level;
    989            
    990            return 0;
    991          }
    992          
    993          int hci_read_rssi(uint16_t *conn_handle, int8_t * rssi)
    994          {
    995            struct hci_request rq;
    996            read_rssi_cp params;
    997            read_rssi_rp resp;
    998            
    999            Osal_MemSet(&resp, 0, sizeof(resp));
   1000            
   1001            params.handle = *conn_handle;
   1002            
   1003            Osal_MemSet(&rq, 0, sizeof(rq));
   1004            rq.ogf = OGF_STATUS_PARAM;
   1005            rq.ocf = OCF_READ_RSSI;
   1006            rq.cparam = &params;
   1007            rq.clen = READ_RSSI_CP_SIZE;
   1008            rq.rparam = &resp;
   1009            rq.rlen = READ_RSSI_RP_SIZE;
   1010            
   1011            if (hci_send_req(&rq, FALSE) < 0){
   1012              return BLE_STATUS_TIMEOUT;
   1013            }
   1014            
   1015            if (resp.status) {
   1016              return resp.status;
   1017            }
   1018            
   1019            *conn_handle = resp.handle;
   1020            *rssi = resp.rssi;
   1021            
   1022            return 0;
   1023          }
   1024          
   1025          int hci_le_read_local_supported_features(uint8_t *features)
   1026          {
   1027            struct hci_request rq;
   1028            le_read_local_supported_features_rp resp;
   1029            
   1030            Osal_MemSet(&resp, 0, sizeof(resp));
   1031            
   1032            Osal_MemSet(&rq, 0, sizeof(rq));
   1033            rq.ogf = OGF_LE_CTL;
   1034            rq.ocf = OCF_LE_READ_LOCAL_SUPPORTED_FEATURES;
   1035            rq.rparam = &resp;
   1036            rq.rlen = LE_READ_LOCAL_SUPPORTED_FEATURES_RP_SIZE;
   1037            
   1038            if (hci_send_req(&rq, FALSE) < 0){
   1039              return BLE_STATUS_TIMEOUT;
   1040            }
   1041            
   1042            if (resp.status) {
   1043              return resp.status;
   1044            }
   1045            
   1046            Osal_MemCpy(features, resp.features, sizeof(resp.features));
   1047            
   1048            return 0;
   1049          }
   1050          
   1051          int hci_le_read_channel_map(uint16_t conn_handle, uint8_t ch_map[5])
   1052          {
   1053            struct hci_request rq;
   1054            le_read_channel_map_cp params;
   1055            le_read_channel_map_rp resp;
   1056            
   1057            Osal_MemSet(&resp, 0, sizeof(resp));
   1058            
   1059            params.handle = conn_handle;
   1060            
   1061            Osal_MemSet(&rq, 0, sizeof(rq));
   1062            rq.ogf = OGF_LE_CTL;
   1063            rq.ocf = OCF_LE_READ_CHANNEL_MAP;
   1064            rq.cparam = &params;
   1065            rq.clen = LE_READ_CHANNEL_MAP_CP_SIZE;
   1066            rq.rparam = &resp;
   1067            rq.rlen = LE_READ_CHANNEL_MAP_RP_SIZE;
   1068            
   1069            if (hci_send_req(&rq, FALSE) < 0){
   1070              return BLE_STATUS_TIMEOUT;
   1071            }
   1072            
   1073            if (resp.status) {
   1074              return resp.status;
   1075            }
   1076            
   1077            Osal_MemCpy(ch_map, resp.map, 5);
   1078            
   1079            return 0;
   1080          }
   1081          
   1082          int hci_le_read_supported_states(uint8_t states[8])
   1083          {
   1084            struct hci_request rq;
   1085            le_read_supported_states_rp resp;
   1086            
   1087            Osal_MemSet(&resp, 0, sizeof(resp));
   1088            
   1089            Osal_MemSet(&rq, 0, sizeof(rq));
   1090            rq.ogf = OGF_LE_CTL;
   1091            rq.ocf = OCF_LE_READ_SUPPORTED_STATES;
   1092            rq.rparam = &resp;
   1093            rq.rlen = LE_READ_SUPPORTED_STATES_RP_SIZE;
   1094            
   1095            if (hci_send_req(&rq, FALSE) < 0){
   1096              return BLE_STATUS_TIMEOUT;
   1097            }
   1098            
   1099            if (resp.status) {
   1100              return resp.status;
   1101            }
   1102            
   1103            Osal_MemCpy(states, resp.states, 8);
   1104            
   1105            return 0;
   1106          }
   1107          
   1108          int hci_le_receiver_test(uint8_t frequency)
   1109          {
   1110            struct hci_request rq;
   1111            le_receiver_test_cp params;
   1112            uint8_t status;
   1113            
   1114            params.frequency = frequency;
   1115            
   1116            Osal_MemSet(&rq, 0, sizeof(rq));
   1117            rq.ogf = OGF_LE_CTL;
   1118            rq.ocf = OCF_LE_RECEIVER_TEST;
   1119            rq.cparam = &params;
   1120            rq.clen = LE_RECEIVER_TEST_CP_SIZE;
   1121            rq.rparam = &status;
   1122            rq.rlen = 1;
   1123            
   1124            if (hci_send_req(&rq, FALSE) < 0){
   1125              return BLE_STATUS_TIMEOUT;
   1126            }
   1127            
   1128            return status;
   1129          }
   1130          
   1131          int hci_le_transmitter_test(uint8_t frequency, uint8_t length, uint8_t payload)
   1132          {
   1133            struct hci_request rq;
   1134            le_transmitter_test_cp params;
   1135            uint8_t status;
   1136            
   1137            params.frequency = frequency;
   1138            params.length = length;
   1139            params.payload = payload;
   1140            
   1141            Osal_MemSet(&rq, 0, sizeof(rq));
   1142            rq.ogf = OGF_LE_CTL;
   1143            rq.ocf = OCF_LE_TRANSMITTER_TEST;
   1144            rq.cparam = &params;
   1145            rq.clen = LE_TRANSMITTER_TEST_CP_SIZE;
   1146            rq.rparam = &status;
   1147            rq.rlen = 1;
   1148            
   1149            if (hci_send_req(&rq, FALSE) < 0){
   1150              return BLE_STATUS_TIMEOUT;
   1151            }
   1152            
   1153            return status;
   1154          }
   1155          
   1156          int hci_le_test_end(uint16_t *num_pkts)
   1157          {
   1158            struct hci_request rq;
   1159            le_test_end_rp resp;
   1160            
   1161            Osal_MemSet(&resp, 0, sizeof(resp));
   1162            
   1163            Osal_MemSet(&rq, 0, sizeof(rq));
   1164            rq.ogf = OGF_LE_CTL;
   1165            rq.ocf = OCF_LE_TEST_END;
   1166            rq.rparam = &resp;
   1167            rq.rlen = LE_TEST_END_RP_SIZE;
   1168            
   1169            if (hci_send_req(&rq, FALSE) < 0){
   1170              return BLE_STATUS_TIMEOUT;
   1171            }
   1172            
   1173            if (resp.status) {
   1174              return resp.status;
   1175            }
   1176            
   1177            *num_pkts = resp.num_pkts;
   1178            
   1179            return 0;
   1180          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HCI_Init
         8   -> list_init_head
         0   -> list_insert_tail
         8   -> list_insert_tail
      16   HCI_Input
         0   -- Indirect call
        16   -> list_insert_tail
      16   HCI_Isr
        16   -> BlueNRG_SPI_Read_All
        16   -> Clear_SPI_EXTI_Flag
        16   -> HCI_Input
        16   -> SdkEvalSPI_Irq_Pin
        16   -> list_insert_head
        16   -> list_is_empty
        16   -> list_remove_head
     144   HCI_Process
       144   -> BlueNRG_DataPresent
       144   -> BlueNRG_SPI_Read_All
       144   -> Disable_SPI_IRQ
       144   -> Enable_SPI_IRQ
       144   -> HCI_Event_CB
       144   -> list_insert_tail
       144   -> list_is_empty
       144   -> list_remove_head
       0   HCI_Queue_Empty
         0   -> list_is_empty
      40   hci_disconnect
        40   -> Osal_MemSet
        40   -> hci_send_req
      72   hci_le_add_device_to_white_list
        72   -> Enable_SPI_IRQ
        72   -> Hal_Write_Serial
        72   -> Osal_MemCpy
        72   -> Osal_MemSet
        72   -> Timer_Expired
        72   -> Timer_Set
      32   hci_le_clear_white_list
        32   -> Osal_MemSet
        32   -> hci_send_req
      80   hci_le_create_connection
        80   -> Osal_MemCpy
        80   -> Osal_MemSet
        80   -> hci_send_req
      96   hci_le_encrypt
        96   -> Osal_MemCpy
        96   -> Osal_MemSet
        96   -> hci_send_req
      40   hci_le_ltk_request_neg_reply
        40   -> Osal_MemSet
        40   -> hci_send_req
      56   hci_le_ltk_request_reply
        56   -> Osal_MemCpy
        56   -> Osal_MemSet
        56   -> hci_send_req
      48   hci_le_rand
        48   -> Osal_MemCpy
        48   -> Osal_MemSet
        48   -> hci_send_req
      40   hci_le_read_advertising_channel_tx_power
        40   -> Osal_MemSet
        40   -> hci_send_req
      40   hci_le_read_buffer_size
        40   -> Osal_MemSet
        40   -> hci_send_req
      72   hci_le_read_channel_map
        72   -> Enable_SPI_IRQ
        72   -> Hal_Write_Serial
        72   -> Osal_MemCpy
        72   -> Osal_MemSet
        72   -> Timer_Expired
        72   -> Timer_Set
      80   hci_le_read_local_supported_features
        80   -> Enable_SPI_IRQ
        80   -> Hal_Write_Serial
        80   -> Osal_MemCpy
        80   -> Osal_MemSet
        80   -> Timer_Expired
        80   -> Timer_Set
      56   hci_le_read_local_version
        56   -> Osal_MemSet
        56   -> hci_send_req
      80   hci_le_read_supported_states
        80   -> Enable_SPI_IRQ
        80   -> Hal_Write_Serial
        80   -> Osal_MemCpy
        80   -> Osal_MemSet
        80   -> Timer_Expired
        80   -> Timer_Set
      40   hci_le_read_white_list_size
        40   -> Osal_MemSet
        40   -> hci_send_req
      64   hci_le_receiver_test
        64   -> Enable_SPI_IRQ
        64   -> Hal_Write_Serial
        64   -> Osal_MemCpy
        64   -> Osal_MemSet
        64   -> Timer_Expired
        64   -> Timer_Set
      72   hci_le_remove_device_from_white_list
        72   -> Enable_SPI_IRQ
        72   -> Hal_Write_Serial
        72   -> Osal_MemCpy
        72   -> Osal_MemSet
        72   -> Timer_Expired
        72   -> Timer_Set
      40   hci_le_set_advertise_enable
        40   -> Osal_MemSet
        40   -> hci_send_req
      72   hci_le_set_advertising_data
        72   -> Osal_MemCpy
        72   -> Osal_MemSet
        72   -> hci_send_req
      64   hci_le_set_advertising_parameters
        64   -> Osal_MemCpy
        64   -> Osal_MemSet
        64   -> hci_send_req
      48   hci_le_set_random_address
        48   -> Osal_MemCpy
        48   -> Osal_MemSet
        48   -> hci_send_req
      48   hci_le_set_scan_enable
        48   -> Osal_MemSet
        48   -> hci_send_req
      56   hci_le_set_scan_parameters
        56   -> Osal_MemSet
        56   -> hci_send_req
      72   hci_le_set_scan_resp_data
        72   -> Osal_MemCpy
        72   -> Osal_MemSet
        72   -> hci_send_req
      72   hci_le_test_end
        72   -> Enable_SPI_IRQ
        72   -> Hal_Write_Serial
        72   -> Osal_MemCpy
        72   -> Osal_MemSet
        72   -> Timer_Expired
        72   -> Timer_Set
      64   hci_le_transmitter_test
        64   -> Enable_SPI_IRQ
        64   -> Hal_Write_Serial
        64   -> Osal_MemCpy
        64   -> Osal_MemSet
        64   -> Timer_Expired
        64   -> Timer_Set
      40   hci_read_bd_addr
        40   -> Osal_MemCpy
        40   -> Osal_MemSet
        40   -> hci_send_req
      72   hci_read_rssi
        72   -> Enable_SPI_IRQ
        72   -> Hal_Write_Serial
        72   -> Osal_MemCpy
        72   -> Osal_MemSet
        72   -> Timer_Expired
        72   -> Timer_Set
      72   hci_read_transmit_power_level
        72   -> Enable_SPI_IRQ
        72   -> Hal_Write_Serial
        72   -> Osal_MemCpy
        72   -> Osal_MemSet
        72   -> Timer_Expired
        72   -> Timer_Set
      32   hci_reset
        32   -> Osal_MemSet
        32   -> hci_send_req
      24   hci_send_cmd
        24   -> Hal_Write_Serial
        24   -> Osal_MemCpy
      48   hci_send_req
        48   -> Enable_SPI_IRQ
        48   -> Hal_Write_Serial
        48   -> Osal_MemCpy
        48   -> Timer_Expired
        48   -> Timer_Set
       0   hci_write
         0   -> Hal_Write_Serial
       8   new_hci_event
         8   -> Disable_SPI_IRQ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable8
       4  ??DataTable9
      86  HCI_Init
     186  HCI_Input
      94  HCI_Isr
     116  HCI_Process
       8  HCI_Queue_Empty
      76  hci_disconnect
     314  hci_le_add_device_to_white_list
      56  hci_le_clear_white_list
     156  hci_le_create_connection
     118  hci_le_encrypt
      80  hci_le_ltk_request_neg_reply
      94  hci_le_ltk_request_reply
      92  hci_le_rand
      86  hci_le_read_advertising_channel_tx_power
      94  hci_le_read_buffer_size
     340  hci_le_read_channel_map
     336  hci_le_read_local_supported_features
     118  hci_le_read_local_version
     336  hci_le_read_supported_states
      80  hci_le_read_white_list_size
     298  hci_le_receiver_test
     314  hci_le_remove_device_from_white_list
      88  hci_le_set_advertise_enable
      98  hci_le_set_advertising_data
     128  hci_le_set_advertising_parameters
      86  hci_le_set_random_address
      94  hci_le_set_scan_enable
     104  hci_le_set_scan_parameters
     100  hci_le_set_scan_resp_data
     322  hci_le_test_end
     308  hci_le_transmitter_test
      92  hci_read_bd_addr
     342  hci_read_rssi
     350  hci_read_transmit_power_level
      54  hci_reset
      60  hci_send_cmd
     302  hci_send_req
       4  hci_write
      20  new_hci_event
     712  readPacketListFull
          state
          new_packet
          hci_pckt_len
          hci_buffer
          packet_complete_callback
          hciReadPktPool
          hciReadPktRxQueue
          hciReadPacketBuffer

 
   712 bytes in section .bss
 6 062 bytes in section .text
 
 6 062 bytes of CODE memory
   712 bytes of DATA memory

Errors: none
Warnings: none
