###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  12:01:20
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\src\BLE_Chat_main.c
#    Command line =  
#        "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\src\BLE_Chat_main.c" -D
#        USE_STDPERIPH_DRIVER -D STM32L1XX_MD -D SYSCLK_FREQ_HSI_32MHz -D
#        ENABLE_USB -D ENABLE_USB_PRINTF -D CLIENT=1 -lcN "C:\School\2014
#        Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\Client\List\" --diag_suppress Pa050
#        -o "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\Client\Obj\" --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "C:\School\2014 Fall\ECE
#        4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\inc\" -I "C:\School\2014 Fall\ECE
#        4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\Bluetooth
#        LE\SimpleBlueNRG_HCI\" -I "C:\School\2014 Fall\ECE 4900\Bluetooth
#        Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\Bluetooth
#        LE\SimpleBlueNRG_HCI\includes\" -I "C:\School\2014 Fall\ECE
#        4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\" -I
#        "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32_USB-FS-Device_Driver\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32L1xx_StdPeriph_Driver\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\I2C\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\LIS3DH\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\STLM75\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\HTS221\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\LPS25H\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\SDK_Eval_STM32L\inc\"
#        -Ohs --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\Client\List\BLE_Chat_main.lst
#    Object file  =  
#        C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\Client\Obj\BLE_Chat_main.o
#
###############################################################################

C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects V2\Project\BLE_Chat_Client\src\BLE_Chat_main.c
      1          /******************** (C) COPYRIGHT 2014 STMicroelectronics ********************
      2          * File Name          : BLE_Chat_main.c
      3          * Author             : AMS - AAS Division
      4          * Version            : V1.0.1
      5          * Date               : 10-February-2014
      6          * Description        : BlueNRG main file for Chat demo
      7          *********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          /**
     16           * @file  BLE_Chat_main.c
     17           * @brief This is a Chat demo that shows how to implement a simple 2-way communication between two BlueNRG devices.
     18           *
     19           * <!-- Copyright 2014 by STMicroelectronics.  All rights reserved.       *80*-->
     20          
     21          * \section IAR_project IAR project
     22            To use the project with IAR Embedded Workbench for ARM, please follow the instructions below:
     23            -# Open the Embedded Workbench for ARM.
     24            -# From the File->Open->Workspace menu, open the IAR workspace
     25               <tt> ...\\Projects\\Project\\BLE_Chat\\EWARM\\BLE_Chat.eww </tt>
     26            -# Select desired configuration to build
     27            -# Select Project->Rebuild All. This will recompile and link the entire application
     28            -# To download the binary image, please connect STLink to JTAG connector  in your board (if available).
     29            -# Select Project->Download and Debug to download the related binary image.
     30            -# Alternatively, open the BlueNRG GUI, put the board in DFU mode and download the built binary image.
     31            -# Connect the application board to a PC USB port. Open a hyperterminal on the
     32               corresponding USB virtual COMx port with the configuration as described in \ref Serial_IO.
     33          
     34          * \subsection IAR_project_configurations IAR project configurations
     35          
     36            - \c Client - Client role configuration 
     37            - \c Server - Server role configuration
     38            - \c Client_throughput - Client role configuration for throughput test
     39            - \c Server_throughput - Server role configuration for throughput test
     40          
     41          * \section Prebuilt_images Prebuilt images
     42            - BLE_Chat_Client.hex, BLE_Chat_Server.hex 
     43           
     44          * \section Jumper_settings Jumper settings
     45          @table
     46          ------------------------------------------------------
     47          | Jumper name       |  Description                   | 
     48          ------------------------------------------------------
     49          | JP1, if available | USB or Battery supply position | 
     50          
     51          @endtable 
     52          
     53          
     54          * \section Board_supported Board supported
     55          @table
     56          | Board name      | Board revision | NOTE        |
     57          --------------------------------------------------
     58          | STEVAL-IDB002V1 | 3.0            | Eval Kit    |
     59          | STEVAL-IDB003V1 | 1.0            | USB Dongle  |
     60          @endtable
     61          
     62          * \section Serial_IO Serial I/O
     63            The application will listen for keys typed in one node and, on return press, it will send them to the remote node.
     64            The remote node will listen for RF messages and it will output them in the serial port.
     65            In other words everything typed in one node will be visible to the other node and viceversa.
     66          @table
     67          | Parameter name  | Value          | Unit        |
     68          --------------------------------------------------
     69          | Baudrate        | 115200         | bit/sec     |
     70          | Data bits       | 8              | bit         |
     71          | Parity          | None           | bit         |
     72          | Stop bits       | 1              | bit         |
     73          @endtable
     74          
     75          * \section LEDs_description LEDs description
     76          @table
     77          |                  | STEVAL-IDB002V1 | STEVAL-IDB003V1 |                 
     78          | LED name         | Client/Server   | Client/Server   | 
     79          --------------------------------------------------------
     80          | D1               | Not used        | NA              |        
     81          | D2               | Not used        | Not used        |     
     82          | D3               | Not used        | Not used        |     
     83          | D4               | Not used        | NA              |      
     84          | D5               | Not used        | NA              |       
     85          | D6               | Not used        | NA              |       
     86          @endtable
     87           - NA : Not Applicable;
     88          
     89          * \section Buttons_description Buttons description
     90          @table
     91          |                  | STEVAL-IDB002V1 | STEVAL-IDB003V1 |                 
     92          | Button name      | Client/Server   | Client/Server   | 
     93          --------------------------------------------------------
     94          | RESET            | X               | NA              |  
     95          | Push Button      | Not used        | NA              |   
     96          | Jostick Sel      | Not used        | NA              |    
     97          | SW1              | NA              | Not used        |     
     98          | SW2              | NA              | Not used        |       
     99          @endtable
    100           - NA : Not Applicable;
    101          
    102          * \section DFU_Activation  DFU activation
    103          BlueNRG boards are preprogrammed with a DFU application which allows to upload the 
    104          STM32L micro with a selected binary image through USB. Follow list of actions 
    105          for activating DFU on each supported platforms
    106          @table
    107          | Board  name          | Event                                             | Note               |
    108          ------------------------------------------------------------------------------------------------|
    109          | STEVAL-IDB002V1      | Press RESET and Push Button. Release RESET button | LED D2 is toggling |  
    110          | STEVAL-IDB003V1      | Press SW1 button and plug USB dongle on a PC port | LED D3 is toggling |  
    111          @endtable
    112          
    113          * \section Usage Usage
    114          
    115          This Chat demo has  are 2 roles:
    116           - The server that expose the Chat service. It is the slave.
    117           - The client that uses the Chat service. It is the master.
    118          
    119          The Chat Service contains 2 Characteristics:
    120           -# The TX Characteristic: the client can enable notifications on this characteristic. When the server has data to be sent, it will send notifications which will contains the value of the TX Characteristic
    121           -# The RX Characteristic: it is a writable caracteristic. When the client has data to be sent to the server, it will write a value into this characteristic.
    122          
    123          The maximum length of the characteristic value is 20 bytes.
    124          
    125          NOTES:
    126           - The Client_throughput and Server_throughput workspaces allow to target a throughput test (THROUGHPUT_TEST define on the preprocessor options on both workspaces).
    127           - Program the client on one BlueNRG platform and reset it. The platform will be seen on the PC as a virtual COM port. Open the port in a serial terminal emulator. Client will start 4 seconds after reset.
    128           - Program the server on a second BlueNRG platform and reset it. The two platforms will try to establish a connection. As soon as they get connected, the slave will 
    129             send notification to the client of 20 bytes (200 notifications). 
    130           - After all the notifications are received, the measured application throughput will be displayed.
    131          
    132          **/
    133          /** @addtogroup BlueNRG_demonstrations_applications
    134           * BlueNRG Chat demo \see BLE_Chat_main.c for documentation.
    135           *
    136           *@{
    137           */
    138          
    139          /** @} */
    140          /** \cond DOXYGEN_SHOULD_SKIP_THIS
    141           */
    142          /* Includes ------------------------------------------------------------------*/
    143          #include "stm32l1xx.h"
    144          #include "usb_lib.h"
    145          #include "hw_config.h"
    146          #include "hal_types.h"
    147          #include "hci.h"
    148          #include "bluenrg_aci.h"
    149          #include "gp_timer.h"
    150          #include "hal.h"
    151          #include "osal.h"
    152          #include "gatt_db.h"
    153          #include "gatt_server.h"
    154          #include "hci_const.h"
    155          #include "gap.h"
    156          #include "sm.h"
    157          #include "app_state.h"
    158          #include "led.h"
    159          #include "push_button.h"
    160          #include "timer.h"
    161          #include "slave_devices.h"
    162          #include "flags.h"
    163          #include <stdio.h>
    164          #include <string.h>
    165          #include <stdlib.h>
    166          #include "syncr.h"
    167          
    168          #include "SDK_EVAL_Config.h"
    169          
    170          /* External variables --------------------------------------------------------*/
    171          /* Private typedef -----------------------------------------------------------*/
    172          /* Private defines -----------------------------------------------------------*/
    173          /** 
    174            * @brief  Enable debug printf's
    175            */ 
    176          #ifndef DEBUG
    177          #define DEBUG 1
    178          #endif
    179                
    180          #define REQUEST_CONN_PARAM_UPDATE 0     //Flag used to check connection parameters
    181          
    182          /* Private macros ------------------------------------------------------------*/
    183          #if DEBUG
    184          #include <stdio.h>
    185          #define PRINTF(...) printf(__VA_ARGS__)
    186          #else
    187          #define PRINTF(...)
    188          #endif
    189          
    190          #define NUM_PACKETS 200 // Only used for throughput test (define THROUGHPUT_TEST)
    191          
    192          #ifndef VECTOR_TABLE_BASE_ADDRESS 
    193          /* default configuration: DFU upgrade is supported */
    194          #define VECTOR_TABLE_BASE_ADDRESS            (0x3000)   //Vector table bass address
    195          #endif
    196          
    197          /* Private variables ---------------------------------------------------------*/
    198          volatile int app_flags = SET_CONNECTABLE;                       //Set the devices connectable by setting a flag
    199          volatile uint16_t connection_handle = 0;                        //Unique connection handle for a given connection
    200          extern uint16_t chatServHandle, TXCharHandle, RXCharHandle;     //Unique handles for the chat service, TX characteristic and RX characteristic
    201          struct timer l2cap_req_timer;                                   //Timer used when connection parameters are requested
    202          //volatile int numConnected = 0;
    203          volatile int flag_scan_complete = 0;
    204          volatile int flag_connection_complete = 0;
    205          volatile int index = 0;
    206          volatile uint32_t bstimei = 0;
    207          volatile uint32_t hhtimei = 0;
    208          extern uint32_t offsetp = 0;
    209          
    210          /** 
    211            * @brief  Handle of TX,RX  Characteristics.
    212            */ 
    213          #ifdef CLIENT
    214          uint16_t tx_handle;     //Unique TX characteristic handle
    215          uint16_t rx_handle;     //Unique RX characteristic handle
    216          #endif 
    217          
    218          
    219          /* Private function prototypes -----------------------------------------------*/
    220          void Make_Connection(void);     //Used to make BLE connections
    221          void User_Process(void);        //Used to get characteristic handles and enable notifications
    222          void send_times();              // Check times and send them to syncr if both are set
    223          
    224          /* Private functions ---------------------------------------------------------*/
    225          
    226          /*  User Function where serial received data should be processed */
    227          void processInputData(uint8_t * rx_data, uint16_t data_size);   //Used to process received data
    228          
    229          /*******************************************************************************
    230          * Function Name  : main.
    231          * Description    : Main routine.
    232          * Input          : None.
    233          * Output         : None.
    234          * Return         : None.
    235          *******************************************************************************/
    236          int main(void)
    237          {
    238              int ret;    //Used to check status
    239              
    240              NVIC_SetVectorTable(NVIC_VectTab_FLASH, VECTOR_TABLE_BASE_ADDRESS); //Set the Nested Vector Interrupt Controller table bass address
    241              
    242              /* Identify BlueNRG platform */
    243              SdkEvalIdentification();    //Figure out what BlueNRG platform is being used
    244          
    245              RCC_Configuration();        //Configure the Reset and Clock Control (definition located in hw_config.h)
    246              
    247              /* Init I/O ports */
    248              Init_GPIOs ();      //Configure the General Purpose Input/Output ((definition located in hw_config.h))
    249              
    250              PWR_PVDCmd(DISABLE);        //Disable Programmable Voltage Detector
    251              
    252              /* Initialize LEDs and button */
    253              initLED(0); //check LED.c for more info
    254              initLED(3);
    255              initLED(4);
    256              initButton();
    257              
    258              /* Initialize debouncer timer */
    259              initTimer(7,200);   //Timer used to debounce button
    260              enableTimerInterrupt(7);
    261              
    262              /* Initialize (measuring)event timer */
    263              initTimer(2,1000);  //Check timer.c for more info
    264              enableTimerInterrupt(2);
    265              initTimer(4,100);
    266              enableTimerInterrupt(4);
    267              initTimer(6,5000);
    268              enableTimerInterrupt(6);
    269              
    270              /* Initialize slave addresses */
    271              initDevices();
    272              
    273              /* Disable FLASH during Sleep  */
    274              FLASH_SLEEPPowerDownCmd(ENABLE);    //Disable FLASH memory access during sleep
    275              
    276              /* Enable Ultra low power mode */
    277              PWR_UltraLowPowerCmd(ENABLE);       //Enable ultra low power mode
    278              
    279              PWR_FastWakeUpCmd(ENABLE);  //Enable fast wake up
    280              
    281              NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);     //Configure NVIC priority
    282              
    283              Clock_Init();       //Initialize clock library that gives a sample time reference to the BLE stack
    284              
    285              /* Delay needed only to be able to acces the JTAG interface after reset
    286              if it will be disabled later. */
    287              Clock_Wait(500);    
    288              
    289              /* Configure I/O communication channel:
    290                 It requires the void IO_Receive_Data(uint8_t * rx_data, uint16_t data_size) function
    291                 where user received data should be processed */
    292              SdkEval_IO_Config(processInputData);
    293              
    294              /* Delay for debug purpose, in order to see printed data at startup. */
    295              for(int i = 0; i < 100 ; i++){
    296                  printf(".");
    297                  Clock_Wait(70);
    298              }
    299          
    300              HCI_Init(); //Initialize the Host Controller Interface (this is needed for communication)
    301              
    302              /* Init SPI interface */
    303              SdkEvalSpiInit(SPI_MODE_EXTI);      //Initialize the SPI communication which uses an external interrupt
    304              BlueNRG_RST();      //Reset the BlueNRG
    305              
    306              {
    307          #if CLIENT
    308                  uint8_t bdaddr[] = {0xbb, 0x00, 0x00, 0xE1, 0x80, 0x02};        //CLIENT ADDRESS
    309                  uint8_t role[] = {0x03};        //Master role (can connect with up to 8 slaves)
    310                  ret = aci_hal_write_config_data(CONFIG_DATA_ROLE, 0x01, role);  //Configure client as master (allowing up to 8 slave connections)
    311                  if(ret){
    312                      PRINTF("Configuration as master failed.\n");        //If configuration fails, print a message
    313                  }
    314          #else
    315                  uint8_t bdaddr[] = {0xaa, 0x00, 0x00, 0xE1, 0x80, 0x02};        //Slave address (essentially commented out in the client code)
    316          #endif
    317                  ret = aci_hal_write_config_data(CONFIG_DATA_PUBADDR_OFFSET, CONFIG_DATA_PUBADDR_LEN,    //Configure device address
    318                                                  bdaddr);
    319                  if(ret){
    320                      PRINTF("Setting BD_ADDR failed.\n");        //Failure message
    321                  }
    322              }
    323              
    324              ret = aci_gatt_init();    //Initialize the Generic Attribute Profile
    325              if(ret){
    326                  PRINTF("GATT_Init failed.\n");  //Failure message
    327              }
    328              
    329              {
    330                  uint16_t service_handle, dev_name_char_handle, appearance_char_handle;  //Handles for a service that each BLE device must implement
    331          #if SERVER
    332                  ret = aci_gap_init(GAP_PERIPHERAL_ROLE, &service_handle, &dev_name_char_handle, &appearance_char_handle);       //Initialize the Generic Access Profile 
    333          #else
    334                  ret = aci_gap_init(GAP_CENTRAL_ROLE, &service_handle, &dev_name_char_handle, &appearance_char_handle);          //The client is initialized in the central role and the servers are initialized in peripheral role
    335          #endif
    336                  if(ret){
    337                      PRINTF("GAP_Init failed.\n");       //Error message
    338                  }
    339              }
    340            
    341              ret = aci_gap_set_auth_requirement(MITM_PROTECTION_REQUIRED,        //Make devices use a pin for connection
    342                                                 OOB_AUTH_DATA_ABSENT,
    343                                                 NULL,
    344                                                 7,
    345                                                 16,
    346                                                 USE_FIXED_PIN_FOR_PAIRING,
    347                                                 123456,
    348                                                 BONDING);
    349              PRINTF("BLE Stack Initialized.\r\n");
    350              
    351          #if  SERVER
    352              PRINTF("SERVER: BLE Stack Initialized (platform: %d)\n\r", SdkEvalGetVersion());
    353              ret = Add_Chat_Service();   //Add the chat service along with its TX and RX characteristics
    354              
    355              if(ret == BLE_STATUS_SUCCESS)
    356                  PRINTF("Service added successfully.\n");
    357              else
    358                  PRINTF("Error while adding service.\n");
    359              
    360          #else
    361              PRINTF("CLIENT: BLE Stack Initialized  (platform: %d)\n\r", SdkEvalGetVersion());
    362          #endif 
    363              
    364              /* -2 dBm output power */
    365              ret = aci_hal_set_tx_power_level(1,4);      //Set transmission power level
    366                  
    367          /****************************** Main Execution Loop ***************************/
    368              while(1)
    369              { 
    370                  //printf("main\r\n");
    371                  HCI_Process();          //Process any transmission,reception,etc.
    372                  User_Process();         //Update connections and get characteristic handles if needed
    373                  
    374                  //Check for button presses
    375                  if (!GPIO_ReadInputDataBit(GPIOC, BUTTON) && buttonOK)       //If the button has been pressed
    376                  {
    377                      buttonOK = false;
    378                      startTimer(7);      //Debounce timer
    379                      //Send stimulate command to other blueNRG
    380                      uint8_t data_buffer[] = {0x45,0x56,0x45,0x4e,0x54,0x0d};    //ASCII for "EVENT"
    381                      uint16_t Nb_bytes = 6;      //Data buffer size
    382                      processInputData(data_buffer, Nb_bytes);    //Transmit the data buffer
    383                      //Schedule measuring event
    384                      startTimer(2);
    385                  } 
    386              }
    387          }
    388          
    389          
    390          /**
    391            * @brief  Make the device connectable and make connections
    392            * @param  None 
    393            * @retval None
    394            */
    395          void Make_Connection(void)
    396          {  
    397              tBleStatus ret;     //Used to check status
    398              
    399              
    400          #if CLIENT
    401              
    402              /* Start general discovery procedure */
    403              if(0)
    404              {
    405                ret = aci_gap_start_general_discovery_proc(0x4000, 0x4000,PUBLIC_ADDR, 0x00);       //Scan for devices
    406                if (ret != 0){
    407                      PRINTF("Error while starting general discovery.\r\n");
    408                      Clock_Wait(100);        
    409                      }
    410                //Wait for procedure to complete
    411                while(!flag_scan_complete)
    412                {
    413                  //printf("case1\r\n");
    414                  HCI_Process();    //Continue to process incoming data. The EVT_BLUE_GAP_PROCEDURE_COMPLETE event occurs when scanning is complete
    415                }
    416                Clock_Wait(100);
    417              }
    418              
    419             
    420                  ret = aci_gap_create_connection(0x4000, 0x4000, PUBLIC_ADDR, slaves[index].bdaddr, PUBLIC_ADDR, 0x0020, 0x0020, 0, 0x0064, 0 , 0x03e8);
    421                  if (ret != 0){
    422                      PRINTF("Error while starting connection to server %d.\n", index);
    423                      Clock_Wait(100);
    424                  }
    425                  while(!flag_connection_complete)
    426                  {
    427                   
    428                      HCI_Process();    //EVT_LE_META_EVENT event triggered when connection is complete
    429                  }
    430                  flag_connection_complete = 0;
    431           
    432          #else
    433              
    434              const char local_name[] = {AD_TYPE_COMPLETE_LOCAL_NAME,'B','l','u','e','N','R','G','_','C','h','a','t'};    //Name server advertises
    435              
    436              /* disable scan response */
    437              hci_le_set_scan_resp_data(0,NULL);
    438              
    439              PRINTF("General Discoverable Mode ");       //Sets server in discoverable mode
    440              ret = aci_gap_set_discoverable(ADV_IND, 0, 0, PUBLIC_ADDR, NO_WHITE_LIST_USE,
    441                                             13, local_name, 0, NULL, 0, 0);
    442          
    443              PRINTF("%d\n\r",ret);
    444          #endif
    445          }
    446          
    447          /**
    448            * @brief  This function is called when there is a LE Connection Complete event.
    449            * @param  addr Address of peer device
    450            * @param  handle Connection handle
    451            * @retval None
    452            */
    453          void GAP_ConnectionComplete_CB(uint8_t addr[6], uint16_t handle)
    454          {    
    455              APP_FLAG_SET(CONNECTED);    //Change flag to indicate that the device is connected
    456              for(int i = 0; i < numSlaves; i++)
    457              {
    458                if(slaves[i].bdaddr[0] == addr[0])
    459                {
    460                  slaves[i].connection_handle = handle; //Store the connection handle
    461                  printf("device %d connection handle: %x\r\n", i, handle);
    462                  break;
    463                }
    464              }
    465              
    466              //Turn on Connection LED
    467              turnLED(3,ON);      //Turn on blue LED to indicate that device is connected
    468              flag_connection_complete = 1;
    469              printf("Connected to: ");   //Print the address of the device that was connected to
    470              for(int i = 5; i > 0; i--){
    471                  PRINTF("%02X-", addr[i]);
    472              }
    473              PRINTF("%02X\n\r", addr[0]);
    474              
    475          #if REQUEST_CONN_PARAM_UPDATE   //Used to request a connection parameter update
    476              APP_FLAG_CLEAR(L2CAP_PARAM_UPD_SENT);
    477              Timer_Set(&l2cap_req_timer, CLOCK_SECOND*2);
    478          #endif
    479              
    480          }
    481          
    482          /**
    483            * @brief  This function is called when the peer device get disconnected.
    484            * @param  None 
    485            * @retval None
    486            */
    487          void GAP_DisconnectionComplete_CB(void)
    488          {
    489            //Turn off Connection LED
    490            //numConnected -= 1;
    491            turnLED(3,OFF);       //Turn off connection LED
    492            flag_scan_complete = 0;
    493            flag_connection_complete = 0;
    494              APP_FLAG_CLEAR(CONNECTED);  //Clear flags
    495              PRINTF("Disconnected\n\r");
    496              /* Make the device connectable again. */
    497              APP_FLAG_SET(SET_CONNECTABLE);
    498              APP_FLAG_CLEAR(NOTIFICATIONS_ENABLED);
    499              
    500              APP_FLAG_CLEAR(START_READ_TX_CHAR_HANDLE);
    501              APP_FLAG_CLEAR(END_READ_TX_CHAR_HANDLE);
    502              APP_FLAG_CLEAR(START_READ_RX_CHAR_HANDLE); 
    503              APP_FLAG_CLEAR(END_READ_RX_CHAR_HANDLE); 
    504          }
    505          
    506          /**
    507            * @brief  This function is called when there is a notification from the sever.
    508            * @param  attr_handle Handle of the attribute
    509            * @param  attr_len    Length of attribute value in the notification
    510            * @param  attr_value  Attribute value in the notification
    511            * @retval None
    512            */
    513          void GATT_Notification_CB(uint16_t attr_handle, uint8_t attr_len, uint8_t *attr_value)
    514          {
    515          #if THROUGHPUT_TEST && CLIENT   //Only used for throughput testing
    516              static tClockTime time, time2;
    517              static int packets=0;     
    518              
    519              if(attr_handle == tx_handle+1){ 
    520                  if(packets==0){
    521                      printf("Test start\n\r");
    522                      time = Clock_Time();
    523                  }
    524                  
    525                  for(int i = 0; i < attr_len; i++)
    526                    printf("%c", attr_value[i]);
    527                  
    528                  printf("[RX: %d]", packets);//TBR
    529                  
    530                  packets++;
    531                  
    532                  if(packets == NUM_PACKETS){
    533                      time2 = Clock_Time();
    534                      tClockTime diff = time2-time;
    535                      printf("\n%d packets. Elapsed time: %d ms. App throughput: %.2f kbps.\n\r", NUM_PACKETS, diff, (float)NUM_PACKETS*20*8/diff);
    536                  }        
    537                  
    538              }
    539          #elif CLIENT    //When the client receives a notafication (message) from the server
    540              for(int i = 0; i < numSlaves; i++)
    541              {
    542                if(attr_handle == slaves[i].tx_handle+1){     //If the notification is from the TX attribute...
    543                  printf("received %d: ",i);
    544                  
    545                  if(attr_value[0] == 'B'){
    546                    if(attr_value[1] == 'T'){
    547                      char array[40];
    548                      int index = 2;
    549                      int j = 0;
    550                      
    551                      while(attr_value[index] != '\n'){
    552                        array[j] = attr_value[index];
    553                        j++;
    554                        index++;
    555                      }
    556                        bstimei = s2i(array);
    557                        send_times();
    558                      
    559                    }
    560                      else if(attr_value[1] == 'E'){
    561                        char array[40];
    562                        array[0] = '1';
    563                        for(int index = 1; index <attr_len; index++){
    564                            array[index] = attr_value[index];
    565                            
    566                        }
    567                          processInputData(array, attr_len);
    568                    }
    569                  }
    570                  else if (attr_value[0] == 'H'){
    571                      if(attr_value[1] == 'T'){
    572                      char array[40];
    573                      int index = 2;
    574                      int j = 0;
    575                      
    576                      while(attr_value[index] != '\n'){
    577                        array[j] = attr_value[index];
    578                        j++;
    579                        index++;
    580                      }
    581                        hhtimei = s2i(array);
    582                        send_times(bstimei, hhtimei);
    583                      
    584                    }
    585                      else if(attr_value[1] == 'E'){
    586                        char array[40];
    587                        array[0] = '0';
    588                        for(int index = 1; index <attr_len; index++){
    589                            array[index] = attr_value[index];
    590                            
    591                        }
    592                          processInputData(array, attr_len);
    593                      
    594                    }
    595                  }  
    596                  for(int i = 0; i < attr_len; i++) //Print out the received message
    597                    printf("%c",attr_value[i]);
    598                  printf("\r\n");
    599                  break;
    600                }
    601              }
    602          #endif
    603          }
    604          
    605          
    606          void send_times(){
    607            
    608            if((bstimei != 0) && (hhtimei != 0)){
    609              
    610              offsetp = calculate( bstimei,  hhtimei);
    611              
    612              bstimei = 0;
    613              hhtimei = 0;
    614              
    615              
    616              char number[33];
    617              sprintf(number, "%d", offsetp);
    618              char messageB[36];
    619              char messageH[36];
    620              messageB[0] = '0';
    621              messageH[0] = '1';
    622              messageB[1] = 'O';
    623              messageH[1] = 'O';
    624              int j = 2;
    625              for(int index = 0; index < 33; index++){
    626                messageB[j] = number[index];
    627                messageH[j] = number[index];
    628                j++;
    629              }
    630              processInputData(messageB, 36);
    631              processInputData(messageH, 36);
    632              
    633              
    634            } 
    635            
    636            
    637          }
    638          
    639          void User_Process(void)
    640          {
    641              if(arrayFlags[index].set_connectable){
    642                  Make_Connection();      //If devices need to be connected, connect them
    643                  changeFlag(CLEAR, &arrayFlags[index].set_connectable);        //Update connection flag status
    644              }
    645          
    646          #if REQUEST_CONN_PARAM_UPDATE    
    647              if(APP_FLAG(CONNECTED) && !APP_FLAG(L2CAP_PARAM_UPD_SENT) && Timer_Expired(&l2cap_req_timer)){
    648                  printf("got here\r\n");
    649                  aci_l2cap_connection_parameter_update_request(connection_handle, 8, 16, 0, 600);
    650                  APP_FLAG_SET(L2CAP_PARAM_UPD_SENT);
    651              }
    652          #endif
    653              
    654          #if CLIENT      //Each loop the flags are checked to see what needs to be done
    655                          //Things such as discovering the TX/RX characteristic handles and enabling notifications are done
    656              
    657              
    658              /* Start TX handle Characteristic discovery if not yet done */
    659              if (APP_FLAG(CONNECTED) && !arrayFlags[index].end_read_TX_char_handle)
    660              {
    661                if (!arrayFlags[index].start_read_TX_char_handle)
    662                {
    663                  /* Discovery TX characteristic handle by UUID 128 bits */
    664                  
    665                   const uint8_t charUuid128_TX[16] = {0x66,0x9a,0x0c,0x20,0x00,0x08,0x96,0x9e,0xe2,0x11,0x9e,0xb1,0xe1,0xf2,0x73,0xd9};
    666                   
    667                   aci_gatt_disc_charac_by_uuid(slaves[index].connection_handle, 0x0001, 0xFFFF,UUID_TYPE_128,
    668                                                             charUuid128_TX);
    669                   changeFlag(SET, &arrayFlags[index].start_read_TX_char_handle);
    670                }
    671              }
    672              /* Start RX handle Characteristic discovery if not yet done */
    673              else if (APP_FLAG(CONNECTED) && !arrayFlags[index].end_read_RX_char_handle)
    674              {
    675                //printf("Haven't finished reading RX handle");
    676                /* Discovery RX characteristic handle by UUID 128 bits */
    677                if (!arrayFlags[index].start_read_RX_char_handle)
    678                {
    679                  /* Discovery TX characteristic handle by UUID 128 bits */
    680                  //printf("attempting to read RX handle\r\n");
    681                   const uint8_t charUuid128_RX[16] = {0x66,0x9a,0x0c,0x20,0x00,0x08,0x96,0x9e,0xe2,0x11,0x9e,0xb1,0xe2,0xf2,0x73,0xd9};
    682                   aci_gatt_disc_charac_by_uuid(slaves[index].connection_handle, 0x0001, 0xFFFF,UUID_TYPE_128,
    683                                                             charUuid128_RX);
    684                   changeFlag(SET, &arrayFlags[index].start_read_RX_char_handle);
    685                 }
    686              }
    687              
    688              if(APP_FLAG(CONNECTED) && arrayFlags[index].end_read_TX_char_handle && arrayFlags[index].end_read_RX_char_handle && !arrayFlags[index].notifications_enabled){
    689                  uint8_t client_char_conf_data[] = {0x01, 0x00}; // Enable notifications
    690                  struct timer t;
    691                  Timer_Set(&t, CLOCK_SECOND*10);
    692                  
    693                  while(aci_gatt_write_charac_descriptor(slaves[index].connection_handle, slaves[index].tx_handle+2, 2, client_char_conf_data)==BLE_STATUS_NOT_ALLOWED){ //TX_HANDLE;
    694                      // Radio is busy.
    695                      if(Timer_Expired(&t)) break;
    696                  }
    697                  changeFlag(SET, &arrayFlags[index].notifications_enabled);
    698                }
    699              else if(APP_FLAG(CONNECTED) && arrayFlags[index].end_read_TX_char_handle && arrayFlags[index].end_read_RX_char_handle && arrayFlags[index].notifications_enabled){
    700                  int numdevices = sizeof(slaves)/sizeof(sDevice);
    701                  if(index < numdevices - 1)
    702                    index++;        
    703              }
    704          #endif
    705              
    706              
    707          #if THROUGHPUT_TEST && SERVER   //Used for throughput testing
    708              
    709              printf("Throughput test\r\n");
    710              static uint8_t test_done = FALSE;
    711              
    712              if(APP_FLAG(CONNECTED) && !test_done && APP_FLAG(NOTIFICATIONS_ENABLED)){
    713              
    714                  uint8_t data[20] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J'};
    715                  
    716                  static tClockTime time, time2;
    717                  time = Clock_Time();
    718                  
    719                  for(int i = 0; i < NUM_PACKETS; i++){
    720                      
    721                      struct timer t;
    722                      Timer_Set(&t, CLOCK_SECOND*10);
    723                                      
    724                      while(aci_gatt_update_char_value(chatServHandle, TXCharHandle, 0, 20, data)==BLE_STATUS_INSUFFICIENT_RESOURCES)
    725                      {
    726                        // Radio is busy (buffer full).
    727                        if(Timer_Expired(&t))
    728                            break;
    729                      }
    730                  
    731                  }
    732                  
    733                  time2 = Clock_Time();
    734                  tClockTime diff = time2-time;
    735                  printf("\n%d packets. Elapsed time: %d ms. App throughput: %.2f kbps.\n\r", NUM_PACKETS, diff, (float)NUM_PACKETS*20*8/diff);
    736                  
    737                  test_done = TRUE;
    738              }
    739          #endif
    740              
    741          }
    742          
    743          /**
    744            * @brief  This function is called whenever there is an ACI event to be processed.
    745            * @note   Inside this function each event must be identified and correctly
    746            *         parsed.
    747            * @param  pckt  Pointer to the ACI packet
    748            * @retval None
    749            */
    750          void HCI_Event_CB(void *pckt)   //This function is called when ACI events occur (such as when a connection is complete)
    751          {
    752              hci_uart_pckt *hci_pckt = pckt;
    753              hci_event_pckt *event_pckt = (hci_event_pckt*)hci_pckt->data;
    754              
    755              if(hci_pckt->type != HCI_EVENT_PKT)
    756                  return;
    757              
    758              switch(event_pckt->evt){
    759                  
    760              case EVT_DISCONN_COMPLETE:
    761                  {
    762                      GAP_DisconnectionComplete_CB();
    763                  }
    764                  break;
    765                  
    766              case EVT_LE_META_EVENT:
    767                  {
    768                      evt_le_meta_event *evt = (void *)event_pckt->data;
    769                      
    770                      switch(evt->subevent){
    771                      case EVT_LE_CONN_COMPLETE:
    772                          {
    773                              evt_le_connection_complete *cc = (void *)evt->data;
    774                              GAP_ConnectionComplete_CB(cc->peer_bdaddr, cc->handle);
    775                          }
    776                          break;
    777                      }
    778                  }
    779                  break;
    780                  
    781              case EVT_VENDOR:
    782                  {
    783                      evt_blue_aci *blue_evt = (void*)event_pckt->data;
    784                      switch(blue_evt->ecode){
    785                          
    786                      case EVT_BLUE_GATT_ATTRIBUTE_MODIFIED:
    787                          {
    788                              evt_gatt_attr_modified *evt = (evt_gatt_attr_modified*)blue_evt->data;
    789                              Attribute_Modified_CB(evt->attr_handle, evt->data_length, evt->att_data);                    
    790                          }
    791                          break;
    792                      case EVT_BLUE_GATT_NOTIFICATION:
    793                          {
    794                              evt_gatt_attr_notification *evt = (evt_gatt_attr_notification*)blue_evt->data;
    795                              GATT_Notification_CB(evt->attr_handle, evt->event_data_length - 2, evt->attr_value);
    796                          }
    797                          break;
    798                       case EVT_BLUE_L2CAP_CONN_UPD_RESP:
    799                          {
    800                              evt_l2cap_conn_upd_resp *resp = (void*)blue_evt->data;
    801                              if(resp->result){
    802                                  PRINTF("> Connection parameters rejected.\n");
    803                              }
    804                              else{
    805                                  PRINTF("> Connection parameters accepted.\n");
    806                              }
    807                          }
    808                          break;
    809          #ifdef CLIENT            
    810                        case EVT_BLUE_GATT_DISC_READ_CHAR_BY_UUID_RESP:
    811                          {
    812                              evt_gatt_disc_read_char_by_uuid_resp *resp = (void*)blue_evt->data;
    813                              
    814                              if (arrayFlags[index].start_read_TX_char_handle && !arrayFlags[index].end_read_TX_char_handle)
    815                              {
    816                                slaves[index].tx_handle = resp->attr_handle;
    817                                PRINTF("Device %d TX Char Handle: %04X\n\r", index, slaves[index].tx_handle);
    818                              }
    819                              else if (arrayFlags[index].start_read_RX_char_handle && !arrayFlags[index].end_read_RX_char_handle)
    820                              {
    821                                slaves[index].rx_handle = resp->attr_handle;
    822                                PRINTF("Device %d RX Char Handle: %04X\n\r", index, slaves[index].rx_handle);
    823                              }
    824                          }
    825                          break;  
    826                          
    827                          case EVT_BLUE_GATT_PROCEDURE_COMPLETE:
    828                          {
    829                            /* Wait for gatt procedure complete event trigger related to Discovery Charac by UUID */
    830                            //evt_gatt_procedure_complete *pr = (void*)blue_evt->data;
    831                            
    832                            if (arrayFlags[index].start_read_TX_char_handle && !arrayFlags[index].end_read_TX_char_handle)
    833                            {
    834                              changeFlag(SET, &arrayFlags[index].end_read_TX_char_handle);
    835                              //printf("tried to set TX flag\r\nTX flag is %d\r\n",arrayFlags[index].end_read_TX_char_handle);
    836                            }
    837                            else if (arrayFlags[index].start_read_RX_char_handle && !arrayFlags[index].end_read_RX_char_handle)
    838                            {
    839                              changeFlag(SET, &arrayFlags[index].end_read_RX_char_handle);
    840                            }
    841                          }
    842                          break;
    843                          
    844                          case EVT_BLUE_GAP_PROCEDURE_COMPLETE:
    845                          {
    846                            flag_scan_complete = 1;
    847                          }
    848                          break;
    849          #endif         
    850                      }
    851                  }
    852                  break;
    853              }
    854              
    855          }
    856          
    857          
    858          #ifdef USE_FULL_ASSERT
    859          /*******************************************************************************
    860          * Function Name  : assert_failed
    861          * Description    : Reports the name of the source file and the source line number
    862          *                  where the assert_param error has occurred.
    863          * Input          : - file: pointer to the source file name
    864          *                  - line: assert_param error line source number
    865          * Output         : None
    866          * Return         : None
    867          *******************************************************************************/
    868          void assert_failed(uint8_t* file, uint32_t line)
    869          {
    870              /* User can add his own implementation to report the file name and line number,
    871              ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
    872              
    873              /* Infinite loop */
    874              while (1)
    875              {
    876                printf("\r\nFailed\r\n");
    877                Clock_Wait(10000);
    878              }
    879          }
    880          #endif
    881          
    882          /******************* (C) COPYRIGHT 2014 STMicroelectronics *****END OF FILE****/
    883          /** \endcond
    884           */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   GAP_ConnectionComplete_CB
         0   -> printf
        16   -> printf
        16   -> turnLED
       8   GAP_DisconnectionComplete_CB
         8   -> printf
         8   -> turnLED
      56   GATT_Notification_CB
        56   -> printf
        56   -> processInputData
        56   -> s2i
        56   -> send_times
       8   HCI_Event_CB
         0   -> Attribute_Modified_CB
         0   -> GAP_ConnectionComplete_CB
         0   -> GAP_DisconnectionComplete_CB
         0   -> GATT_Notification_CB
         0   -> changeFlag
         0   -> printf
      40   Make_Connection
        40   -> Clock_Wait
        40   -> HCI_Process
        40   -> aci_gap_create_connection
        40   -> printf
      40   User_Process
        40   -> Make_Connection
        40   -> Timer_Expired
        40   -> Timer_Set
        40   -> aci_gatt_disc_charac_by_uuid
        40   -> aci_gatt_write_charac_descriptor
        40   -> changeFlag
      32   main
        32   -> BlueNRG_RST
        32   -> Clock_Init
        32   -> Clock_Wait
        32   -> FLASH_SLEEPPowerDownCmd
        32   -> GPIO_ReadInputDataBit
        32   -> HCI_Init
        32   -> HCI_Process
        32   -> Init_GPIOs
        32   -> NVIC_PriorityGroupConfig
        32   -> NVIC_SetVectorTable
        32   -> PWR_FastWakeUpCmd
        32   -> PWR_PVDCmd
        32   -> PWR_UltraLowPowerCmd
        32   -> RCC_Configuration
        32   -> SdkEvalGetVersion
        32   -> SdkEvalIdentification
        32   -> SdkEvalSpiInit
        32   -> SdkEval_IO_Config
        32   -> User_Process
        32   -> aci_gap_init
        32   -> aci_gap_set_auth_requirement
        32   -> aci_gatt_init
        32   -> aci_hal_set_tx_power_level
        32   -> aci_hal_write_config_data
        32   -> enableTimerInterrupt
        32   -> initButton
        32   -> initDevices
        32   -> initLED
        32   -> initTimer
        32   -> printf
        32   -> processInputData
        32   -> startTimer
     120   send_times
       120   -> calculate
       120   -> processInputData
       120   -> sprintf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable30
       4  ??DataTable33
       4  ??DataTable33_1
       4  ??DataTable33_2
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable34_2
       4  ??DataTable34_3
       4  ??DataTable34_4
       4  ??DataTable34_5
       4  ??DataTable34_6
       4  ??DataTable34_7
       4  ??DataTable34_8
       2  ?_0
       8  ?_1
      48  ?_10
      36  ?_11
      16  ?_12
       8  ?_13
       8  ?_14
      16  ?_15
      16  ?_16
       4  ?_17
       4  ?_18
       4  ?_19
       1  ?_2
      16  ?_20
      16  ?_21
       2  ?_22
      36  ?_23
      36  ?_24
      36  ?_25
      36  ?_26
      36  ?_3
      28  ?_4
      20  ?_5
      20  ?_6
      28  ?_7
      48  ?_8
       8  ?_9
     140  GAP_ConnectionComplete_CB
      86  GAP_DisconnectionComplete_CB
     360  GATT_Notification_CB
     410  HCI_Event_CB
     102  Make_Connection
     410  User_Process
      16  app_flags
          flag_scan_complete
          flag_connection_complete
          index
      12  bstimei
          hhtimei
          offsetp
       2  connection_handle
       8  l2cap_req_timer
     432  main
       2  rx_handle
     146  send_times
       2  tx_handle

 
    26 bytes in section .bss
    16 bytes in section .data
    14 bytes in section .rodata
 2 661 bytes in section .text
 
 2 661 bytes of CODE  memory
    14 bytes of CONST memory
    42 bytes of DATA  memory

Errors: none
Warnings: 9
