###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        12/Mar/2015  12:51:32
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Rex\Desktop\Github\trunk\Projects
#        V2\Project\BLE_Chat_Client\src\BLE_Chat_main.c
#    Command line =  
#        "C:\Users\Rex\Desktop\Github\trunk\Projects
#        V2\Project\BLE_Chat_Client\src\BLE_Chat_main.c" -D
#        USE_STDPERIPH_DRIVER -D STM32L1XX_MD -D SYSCLK_FREQ_HSI_32MHz -D
#        ENABLE_USB -D ENABLE_USB_PRINTF -D CLIENT=1 -lcN
#        "C:\Users\Rex\Desktop\Github\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\Client\List\" --diag_suppress Pa050
#        -o "C:\Users\Rex\Desktop\Github\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\Client\Obj\" --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\Users\Rex\Desktop\Github\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\inc\" -I
#        "C:\Users\Rex\Desktop\Github\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\Bluetooth
#        LE\SimpleBlueNRG_HCI\" -I "C:\Users\Rex\Desktop\Github\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\Bluetooth
#        LE\SimpleBlueNRG_HCI\includes\" -I
#        "C:\Users\Rex\Desktop\Github\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\" -I
#        "C:\Users\Rex\Desktop\Github\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\"
#        -I "C:\Users\Rex\Desktop\Github\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\"
#        -I "C:\Users\Rex\Desktop\Github\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32_USB-FS-Device_Driver\inc\"
#        -I "C:\Users\Rex\Desktop\Github\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32L1xx_StdPeriph_Driver\inc\"
#        -I "C:\Users\Rex\Desktop\Github\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\I2C\inc\"
#        -I "C:\Users\Rex\Desktop\Github\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\LIS3DH\inc\"
#        -I "C:\Users\Rex\Desktop\Github\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\STLM75\inc\"
#        -I "C:\Users\Rex\Desktop\Github\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\HTS221\inc\"
#        -I "C:\Users\Rex\Desktop\Github\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\LPS25H\inc\"
#        -I "C:\Users\Rex\Desktop\Github\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\..\..\..\platform\STM32L1XX\Libraries\SDK_Eval_STM32L\inc\"
#        -Ohs --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\Users\Rex\Desktop\Github\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\Client\List\BLE_Chat_main.lst
#    Object file  =  
#        C:\Users\Rex\Desktop\Github\trunk\Projects
#        V2\Project\BLE_Chat_Client\EWARM\Client\Obj\BLE_Chat_main.o
#
###############################################################################

C:\Users\Rex\Desktop\Github\trunk\Projects V2\Project\BLE_Chat_Client\src\BLE_Chat_main.c
      1          /******************** (C) COPYRIGHT 2014 STMicroelectronics ********************
      2          * File Name          : BLE_Chat_main.c
      3          * Author             : AMS - AAS Division
      4          * Version            : V1.0.1
      5          * Date               : 10-February-2014
      6          * Description        : BlueNRG main file for Chat demo
      7          *********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          /**
     16           * @file  BLE_Chat_main.c
     17           * @brief This is a Chat demo that shows how to implement a simple 2-way communication between two BlueNRG devices.
     18           *
     19           * <!-- Copyright 2014 by STMicroelectronics.  All rights reserved.       *80*-->
     20          
     21          * \section IAR_project IAR project
     22            To use the project with IAR Embedded Workbench for ARM, please follow the instructions below:
     23            -# Open the Embedded Workbench for ARM.
     24            -# From the File->Open->Workspace menu, open the IAR workspace
     25               <tt> ...\\Projects\\Project\\BLE_Chat\\EWARM\\BLE_Chat.eww </tt>
     26            -# Select desired configuration to build
     27            -# Select Project->Rebuild All. This will recompile and link the entire application
     28            -# To download the binary image, please connect STLink to JTAG connector  in your board (if available).
     29            -# Select Project->Download and Debug to download the related binary image.
     30            -# Alternatively, open the BlueNRG GUI, put the board in DFU mode and download the built binary image.
     31            -# Connect the application board to a PC USB port. Open a hyperterminal on the
     32               corresponding USB virtual COMx port with the configuration as described in \ref Serial_IO.
     33          
     34          * \subsection IAR_project_configurations IAR project configurations
     35          
     36            - \c Client - Client role configuration 
     37            - \c Server - Server role configuration
     38            - \c Client_throughput - Client role configuration for throughput test
     39            - \c Server_throughput - Server role configuration for throughput test
     40          
     41          * \section Prebuilt_images Prebuilt images
     42            - BLE_Chat_Client.hex, BLE_Chat_Server.hex 
     43           
     44          * \section Jumper_settings Jumper settings
     45          @table
     46          ------------------------------------------------------
     47          | Jumper name       |  Description                   | 
     48          ------------------------------------------------------
     49          | JP1, if available | USB or Battery supply position | 
     50          
     51          @endtable 
     52          
     53          
     54          * \section Board_supported Board supported
     55          @table
     56          | Board name      | Board revision | NOTE        |
     57          --------------------------------------------------
     58          | STEVAL-IDB002V1 | 3.0            | Eval Kit    |
     59          | STEVAL-IDB003V1 | 1.0            | USB Dongle  |
     60          @endtable
     61          
     62          * \section Serial_IO Serial I/O
     63            The application will listen for keys typed in one node and, on return press, it will send them to the remote node.
     64            The remote node will listen for RF messages and it will output them in the serial port.
     65            In other words everything typed in one node will be visible to the other node and viceversa.
     66          @table
     67          | Parameter name  | Value          | Unit        |
     68          --------------------------------------------------
     69          | Baudrate        | 115200         | bit/sec     |
     70          | Data bits       | 8              | bit         |
     71          | Parity          | None           | bit         |
     72          | Stop bits       | 1              | bit         |
     73          @endtable
     74          
     75          * \section LEDs_description LEDs description
     76          @table
     77          |                  | STEVAL-IDB002V1 | STEVAL-IDB003V1 |                 
     78          | LED name         | Client/Server   | Client/Server   | 
     79          --------------------------------------------------------
     80          | D1               | Not used        | NA              |        
     81          | D2               | Not used        | Not used        |     
     82          | D3               | Not used        | Not used        |     
     83          | D4               | Not used        | NA              |      
     84          | D5               | Not used        | NA              |       
     85          | D6               | Not used        | NA              |       
     86          @endtable
     87           - NA : Not Applicable;
     88          
     89          * \section Buttons_description Buttons description
     90          @table
     91          |                  | STEVAL-IDB002V1 | STEVAL-IDB003V1 |                 
     92          | Button name      | Client/Server   | Client/Server   | 
     93          --------------------------------------------------------
     94          | RESET            | X               | NA              |  
     95          | Push Button      | Not used        | NA              |   
     96          | Jostick Sel      | Not used        | NA              |    
     97          | SW1              | NA              | Not used        |     
     98          | SW2              | NA              | Not used        |       
     99          @endtable
    100           - NA : Not Applicable;
    101          
    102          * \section DFU_Activation  DFU activation
    103          BlueNRG boards are preprogrammed with a DFU application which allows to upload the 
    104          STM32L micro with a selected binary image through USB. Follow list of actions 
    105          for activating DFU on each supported platforms
    106          @table
    107          | Board  name          | Event                                             | Note               |
    108          ------------------------------------------------------------------------------------------------|
    109          | STEVAL-IDB002V1      | Press RESET and Push Button. Release RESET button | LED D2 is toggling |  
    110          | STEVAL-IDB003V1      | Press SW1 button and plug USB dongle on a PC port | LED D3 is toggling |  
    111          @endtable
    112          
    113          * \section Usage Usage
    114          
    115          This Chat demo has  are 2 roles:
    116           - The server that expose the Chat service. It is the slave.
    117           - The client that uses the Chat service. It is the master.
    118          
    119          The Chat Service contains 2 Characteristics:
    120           -# The TX Characteristic: the client can enable notifications on this characteristic. When the server has data to be sent, it will send notifications which will contains the value of the TX Characteristic
    121           -# The RX Characteristic: it is a writable caracteristic. When the client has data to be sent to the server, it will write a value into this characteristic.
    122          
    123          The maximum length of the characteristic value is 20 bytes.
    124          
    125          NOTES:
    126           - The Client_throughput and Server_throughput workspaces allow to target a throughput test (THROUGHPUT_TEST define on the preprocessor options on both workspaces).
    127           - Program the client on one BlueNRG platform and reset it. The platform will be seen on the PC as a virtual COM port. Open the port in a serial terminal emulator. Client will start 4 seconds after reset.
    128           - Program the server on a second BlueNRG platform and reset it. The two platforms will try to establish a connection. As soon as they get connected, the slave will 
    129             send notification to the client of 20 bytes (200 notifications). 
    130           - After all the notifications are received, the measured application throughput will be displayed.
    131          
    132          **/
    133          /** @addtogroup BlueNRG_demonstrations_applications
    134           * BlueNRG Chat demo \see BLE_Chat_main.c for documentation.
    135           *
    136           *@{
    137           */
    138          
    139          /** @} */
    140          /** \cond DOXYGEN_SHOULD_SKIP_THIS
    141           */
    142          /* Includes ------------------------------------------------------------------*/
    143          #include "stm32l1xx.h"
    144          #include "usb_lib.h"
    145          #include "hw_config.h"
    146          #include "hal_types.h"
    147          #include "hci.h"
    148          #include "bluenrg_aci.h"
    149          #include "gp_timer.h"
    150          #include "hal.h"
    151          #include "osal.h"
    152          #include "gatt_db.h"
    153          #include "gatt_server.h"
    154          #include "hci_const.h"
    155          #include "gap.h"
    156          #include "sm.h"
    157          #include "app_state.h"
    158          #include "led.h"
    159          #include "push_button.h"
    160          #include "timer.h"
    161          #include "slave_devices.h"
    162          #include "flags.h"
    163          #include <stdio.h>
    164          #include <string.h>
    165          #include <stdlib.h>
    166          #include "syncr.h"
    167          
    168          #include "SDK_EVAL_Config.h"
    169          
    170          /* External variables --------------------------------------------------------*/
    171          /* Private typedef -----------------------------------------------------------*/
    172          /* Private defines -----------------------------------------------------------*/
    173          /** 
    174            * @brief  Enable debug printf's
    175            */ 
    176          #ifndef DEBUG
    177          #define DEBUG 1
    178          #endif
    179                
    180          #define REQUEST_CONN_PARAM_UPDATE 0     //Flag used to check connection parameters
    181          
    182          /* Private macros ------------------------------------------------------------*/
    183          #if DEBUG
    184          #include <stdio.h>
    185          #define PRINTF(...) printf(__VA_ARGS__)
    186          #else
    187          #define PRINTF(...)
    188          #endif
    189          
    190          #define NUM_PACKETS 200 // Only used for throughput test (define THROUGHPUT_TEST)
    191          
    192          #ifndef VECTOR_TABLE_BASE_ADDRESS 
    193          /* default configuration: DFU upgrade is supported */
    194          #define VECTOR_TABLE_BASE_ADDRESS            (0x3000)   //Vector table bass address
    195          #endif
    196          
    197          /* Private variables ---------------------------------------------------------*/
    198          volatile int app_flags = SET_CONNECTABLE;                       //Set the devices connectable by setting a flag
    199          volatile uint16_t connection_handle = 0;                        //Unique connection handle for a given connection
    200          extern uint16_t chatServHandle, TXCharHandle, RXCharHandle;     //Unique handles for the chat service, TX characteristic and RX characteristic
    201          struct timer l2cap_req_timer;                                   //Timer used when connection parameters are requested
    202          //volatile int numConnected = 0;
    203          volatile int flag_scan_complete = 0;
    204          volatile int flag_connection_complete = 0;
    205          volatile int index = 0;
    206          volatile uint32_t bstimei = 0;
    207          volatile uint32_t hhtimei = 0;
    208          extern uint32_t offsetp = 0;
    209          
    210          /** 
    211            * @brief  Handle of TX,RX  Characteristics.
    212            */ 
    213          #ifdef CLIENT
    214          uint16_t tx_handle;     //Unique TX characteristic handle
    215          uint16_t rx_handle;     //Unique RX characteristic handle
    216          #endif 
    217          
    218          
    219          /* Private function prototypes -----------------------------------------------*/
    220          void Make_Connection(void);     //Used to make BLE connections
    221          void User_Process(void);        //Used to get characteristic handles and enable notifications
    222          void send_times();              // Check times and send them to syncr if both are set
    223          
    224          /* Private functions ---------------------------------------------------------*/
    225          
    226          /*  User Function where serial received data should be processed */
    227          void processInputData(uint8_t * rx_data, uint16_t data_size);   //Used to process received data
    228          
    229          /*******************************************************************************
    230          * Function Name  : main.
    231          * Description    : Main routine.
    232          * Input          : None.
    233          * Output         : None.
    234          * Return         : None.
    235          *******************************************************************************/
    236          int main(void)
    237          {
    238              int ret;    //Used to check status
    239              
    240              NVIC_SetVectorTable(NVIC_VectTab_FLASH, VECTOR_TABLE_BASE_ADDRESS); //Set the Nested Vector Interrupt Controller table bass address
    241              
    242              /* Identify BlueNRG platform */
    243              SdkEvalIdentification();    //Figure out what BlueNRG platform is being used
    244          
    245              RCC_Configuration();        //Configure the Reset and Clock Control (definition located in hw_config.h)
    246              
    247              /* Init I/O ports */
    248              Init_GPIOs ();      //Configure the General Purpose Input/Output ((definition located in hw_config.h))
    249              
    250              PWR_PVDCmd(DISABLE);        //Disable Programmable Voltage Detector
    251              
    252              /* Initialize LEDs and button */
    253              initLED(0); //check LED.c for more info
    254              initLED(3);
    255              initLED(4);
    256              initButton();
    257              
    258              /* Initialize debouncer timer */
    259              initTimer(7,200);   //Timer used to debounce button
    260              enableTimerInterrupt(7);
    261              
    262              /* Initialize (measuring)event timer */
    263              initTimer(2,1000);  //Check timer.c for more info
    264              enableTimerInterrupt(2);
    265              initTimer(4,100);
    266              enableTimerInterrupt(4);
    267              initTimer(6,5000);
    268              enableTimerInterrupt(6);
    269              
    270              /* Initialize slave addresses */
    271              initDevices();
    272              
    273              /* Disable FLASH during Sleep  */
    274              FLASH_SLEEPPowerDownCmd(ENABLE);    //Disable FLASH memory access during sleep
    275              
    276              /* Enable Ultra low power mode */
    277              PWR_UltraLowPowerCmd(ENABLE);       //Enable ultra low power mode
    278              
    279              PWR_FastWakeUpCmd(ENABLE);  //Enable fast wake up
    280              
    281              NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);     //Configure NVIC priority
    282              
    283              Clock_Init();       //Initialize clock library that gives a sample time reference to the BLE stack
    284              
    285              /* Delay needed only to be able to acces the JTAG interface after reset
    286              if it will be disabled later. */
    287              Clock_Wait(500);    
    288              
    289              /* Configure I/O communication channel:
    290                 It requires the void IO_Receive_Data(uint8_t * rx_data, uint16_t data_size) function
    291                 where user received data should be processed */
    292              SdkEval_IO_Config(processInputData);
    293              
    294              /* Delay for debug purpose, in order to see printed data at startup. */
    295              for(int i = 0; i < 100 ; i++){
    296                  printf(".");
    297                  Clock_Wait(70);
    298              }
    299          
    300              HCI_Init(); //Initialize the Host Controller Interface (this is needed for communication)
    301              
    302              /* Init SPI interface */
    303              SdkEvalSpiInit(SPI_MODE_EXTI);      //Initialize the SPI communication which uses an external interrupt
    304              BlueNRG_RST();      //Reset the BlueNRG
    305              
    306              {
    307          #if CLIENT
    308                  uint8_t bdaddr[] = {0xbb, 0x00, 0x00, 0xE1, 0x80, 0x02};        //CLIENT ADDRESS
    309                  uint8_t role[] = {0x03};        //Master role (can connect with up to 8 slaves)
    310                  ret = aci_hal_write_config_data(CONFIG_DATA_ROLE, 0x01, role);  //Configure client as master (allowing up to 8 slave connections)
    311                  if(ret){
    312                      PRINTF("Configuration as master failed.\n");        //If configuration fails, print a message
    313                  }
    314          #else
    315                  uint8_t bdaddr[] = {0xaa, 0x00, 0x00, 0xE1, 0x80, 0x02};        //Slave address (essentially commented out in the client code)
    316          #endif
    317                  ret = aci_hal_write_config_data(CONFIG_DATA_PUBADDR_OFFSET, CONFIG_DATA_PUBADDR_LEN,    //Configure device address
    318                                                  bdaddr);
    319                  if(ret){
    320                      PRINTF("Setting BD_ADDR failed.\n");        //Failure message
    321                  }
    322              }
    323              
    324              ret = aci_gatt_init();    //Initialize the Generic Attribute Profile
    325              if(ret){
    326                  PRINTF("GATT_Init failed.\n");  //Failure message
    327              }
    328              
    329              {
    330                  uint16_t service_handle, dev_name_char_handle, appearance_char_handle;  //Handles for a service that each BLE device must implement
    331          #if SERVER
    332                  ret = aci_gap_init(GAP_PERIPHERAL_ROLE, &service_handle, &dev_name_char_handle, &appearance_char_handle);       //Initialize the Generic Access Profile 
    333          #else
    334                  ret = aci_gap_init(GAP_CENTRAL_ROLE, &service_handle, &dev_name_char_handle, &appearance_char_handle);          //The client is initialized in the central role and the servers are initialized in peripheral role
    335          #endif
    336                  if(ret){
    337                      PRINTF("GAP_Init failed.\n");       //Error message
    338                  }
    339              }
    340            
    341              ret = aci_gap_set_auth_requirement(MITM_PROTECTION_REQUIRED,        //Make devices use a pin for connection
    342                                                 OOB_AUTH_DATA_ABSENT,
    343                                                 NULL,
    344                                                 7,
    345                                                 16,
    346                                                 USE_FIXED_PIN_FOR_PAIRING,
    347                                                 123456,
    348                                                 BONDING);
    349              PRINTF("BLE Stack Initialized.\r\n");
    350              
    351          #if  SERVER
    352              PRINTF("SERVER: BLE Stack Initialized (platform: %d)\n\r", SdkEvalGetVersion());
    353              ret = Add_Chat_Service();   //Add the chat service along with its TX and RX characteristics
    354              
    355              if(ret == BLE_STATUS_SUCCESS)
    356                  PRINTF("Service added successfully.\n");
    357              else
    358                  PRINTF("Error while adding service.\n");
    359              
    360          #else
    361              PRINTF("CLIENT: BLE Stack Initialized  (platform: %d)\n\r", SdkEvalGetVersion());
    362          #endif 
    363              
    364              /* -2 dBm output power */
    365              ret = aci_hal_set_tx_power_level(1,4);      //Set transmission power level
    366                  
    367          /****************************** Main Execution Loop ***************************/
    368              while(1)
    369              { 
    370                  //printf("main\r\n");
    371                  HCI_Process();          //Process any transmission,reception,etc.
    372                  User_Process();         //Update connections and get characteristic handles if needed
    373                  
    374                  /*//Check for button presses
    375                  if (!GPIO_ReadInputDataBit(GPIOC, BUTTON) && buttonOK)       //If the button has been pressed
    376                  {
    377                      buttonOK = false;
    378                      startTimer(7);      //Debounce timer
    379                      //Send stimulate command to other blueNRG
    380                      uint8_t data_buffer[] = {0x45,0x56,0x45,0x4e,0x54,0x0d};    //ASCII for "EVENT"
    381                      uint16_t Nb_bytes = 6;      //Data buffer size
    382                      //processInputData(data_buffer, Nb_bytes);    //Transmit the data buffer
    383                      //Schedule measuring event
    384                      startTimer(2);
    385                  }*/
    386                  //printf("%d\n\r",Clock_Time());
    387                  tClockTime ct, mod;
    388                  ct = Clock_Time();
    389                  mod = ct % 10000000;
    390                  if(mod < 100)
    391                  {
    392                    startTimer(2);
    393                    while(Clock_Time() < ct - mod + 100);
    394                    printf("%d\n\r%d\n\r",ct,Clock_Time());
    395                  }
    396              }
    397          }
    398          
    399          
    400          /**
    401            * @brief  Make the device connectable and make connections
    402            * @param  None 
    403            * @retval None
    404            */
    405          void Make_Connection(void)
    406          {  
    407              tBleStatus ret;     //Used to check status
    408              
    409              
    410          #if CLIENT
    411              
    412              /* Start general discovery procedure */
    413              if(0)
    414              {
    415                ret = aci_gap_start_general_discovery_proc(0x4000, 0x4000,PUBLIC_ADDR, 0x00);       //Scan for devices
    416                if (ret != 0){
    417                      PRINTF("Error while starting general discovery.\r\n");
    418                      Clock_Wait(100);        
    419                      }
    420                //Wait for procedure to complete
    421                while(!flag_scan_complete)
    422                {
    423                  //printf("case1\r\n");
    424                  HCI_Process();    //Continue to process incoming data. The EVT_BLUE_GAP_PROCEDURE_COMPLETE event occurs when scanning is complete
    425                }
    426                Clock_Wait(100);
    427              }
    428              
    429             
    430                  ret = aci_gap_create_connection(0x4000, 0x4000, PUBLIC_ADDR, slaves[index].bdaddr, PUBLIC_ADDR, 0x0020, 0x0020, 0, 0x0064, 0 , 0x03e8);
    431                  if (ret != 0){
    432                      PRINTF("Error while starting connection to server %d.\n", index);
    433                      Clock_Wait(100);
    434                  }
    435                  while(!flag_connection_complete)
    436                  {
    437                   //printf("%d\n\r",Clock_Time());
    438                      HCI_Process();    //EVT_LE_META_EVENT event triggered when connection is complete
    439                  }
    440                  flag_connection_complete = 0;
    441           
    442          #else
    443              
    444              const char local_name[] = {AD_TYPE_COMPLETE_LOCAL_NAME,'B','l','u','e','N','R','G','_','C','h','a','t'};    //Name server advertises
    445              
    446              /* disable scan response */
    447              hci_le_set_scan_resp_data(0,NULL);
    448              
    449              PRINTF("General Discoverable Mode ");       //Sets server in discoverable mode
    450              ret = aci_gap_set_discoverable(ADV_IND, 0, 0, PUBLIC_ADDR, NO_WHITE_LIST_USE,
    451                                             13, local_name, 0, NULL, 0, 0);
    452          
    453              PRINTF("%d\n\r",ret);
    454          #endif
    455          }
    456          
    457          /**
    458            * @brief  This function is called when there is a LE Connection Complete event.
    459            * @param  addr Address of peer device
    460            * @param  handle Connection handle
    461            * @retval None
    462            */
    463          void GAP_ConnectionComplete_CB(uint8_t addr[6], uint16_t handle)
    464          {    
    465              APP_FLAG_SET(CONNECTED);    //Change flag to indicate that the device is connected
    466              for(int i = 0; i < numSlaves; i++)
    467              {
    468                if(slaves[i].bdaddr[0] == addr[0])
    469                {
    470                  slaves[i].connection_handle = handle; //Store the connection handle
    471                  printf("device %d connection handle: %x\r\n", i, handle);
    472                  break;
    473                }
    474              }
    475              
    476              //Turn on Connection LED
    477              turnLED(3,ON);      //Turn on blue LED to indicate that device is connected
    478              flag_connection_complete = 1;
    479              printf("Connected to: ");   //Print the address of the device that was connected to
    480              for(int i = 5; i > 0; i--){
    481                  PRINTF("%02X-", addr[i]);
    482              }
    483              PRINTF("%02X\n\r", addr[0]);
    484              
    485          #if REQUEST_CONN_PARAM_UPDATE   //Used to request a connection parameter update
    486              APP_FLAG_CLEAR(L2CAP_PARAM_UPD_SENT);
    487              Timer_Set(&l2cap_req_timer, CLOCK_SECOND*2);
    488          #endif
    489              
    490          }
    491          
    492          /**
    493            * @brief  This function is called when the peer device get disconnected.
    494            * @param  None 
    495            * @retval None
    496            */
    497          void GAP_DisconnectionComplete_CB(void)
    498          {
    499            //Turn off Connection LED
    500            //numConnected -= 1;
    501            turnLED(3,OFF);       //Turn off connection LED
    502            flag_scan_complete = 0;
    503            flag_connection_complete = 0;
    504              APP_FLAG_CLEAR(CONNECTED);  //Clear flags
    505              PRINTF("Disconnected\n\r");
    506              /* Make the device connectable again. */
    507              APP_FLAG_SET(SET_CONNECTABLE);
    508              APP_FLAG_CLEAR(NOTIFICATIONS_ENABLED);
    509              
    510              APP_FLAG_CLEAR(START_READ_TX_CHAR_HANDLE);
    511              APP_FLAG_CLEAR(END_READ_TX_CHAR_HANDLE);
    512              APP_FLAG_CLEAR(START_READ_RX_CHAR_HANDLE); 
    513              APP_FLAG_CLEAR(END_READ_RX_CHAR_HANDLE); 
    514          }
    515          
    516          /**
    517            * @brief  This function is called when there is a notification from the sever.
    518            * @param  attr_handle Handle of the attribute
    519            * @param  attr_len    Length of attribute value in the notification
    520            * @param  attr_value  Attribute value in the notification
    521            * @retval None
    522            */
    523          void GATT_Notification_CB(uint16_t attr_handle, uint8_t attr_len, uint8_t *attr_value)
    524          {
    525          #if THROUGHPUT_TEST && CLIENT   //Only used for throughput testing
    526              static tClockTime time, time2;
    527              static int packets=0;     
    528              
    529              if(attr_handle == tx_handle+1){ 
    530                  if(packets==0){
    531                      printf("Test start\n\r");
    532                      time = Clock_Time();
    533                  }
    534                  
    535                  for(int i = 0; i < attr_len; i++)
    536                    printf("%c", attr_value[i]);
    537                  
    538                  printf("[RX: %d]", packets);//TBR
    539                  
    540                  packets++;
    541                  
    542                  if(packets == NUM_PACKETS){
    543                      time2 = Clock_Time();
    544                      tClockTime diff = time2-time;
    545                      printf("\n%d packets. Elapsed time: %d ms. App throughput: %.2f kbps.\n\r", NUM_PACKETS, diff, (float)NUM_PACKETS*20*8/diff);
    546                  }        
    547                  
    548              }
    549          #elif CLIENT    //When the client receives a notafication (message) from the server
    550              for(int i = 0; i < numSlaves; i++)
    551              {
    552                if(attr_handle == slaves[i].tx_handle+1){     //If the notification is from the TX attribute...
    553                  printf("received %d: ",i);
    554                  
    555                  if(attr_value[0] == 'B'){
    556                    if(attr_value[1] == 'T'){
    557                      char array[40];
    558                      int index = 2;
    559                      int j = 0;
    560                      
    561                      while(attr_value[index] != '\n'){
    562                        array[j] = attr_value[index];
    563                        j++;
    564                        index++;
    565                      }
    566                        bstimei = s2i(array);
    567                        send_times();
    568                      
    569                    }
    570                      else if(attr_value[1] == 'E'){
    571                        char array[40];
    572                        array[0] = '1';
    573                        for(int index = 1; index <attr_len; index++){
    574                            array[index] = attr_value[index];
    575                            
    576                        }
    577                          processInputData(array, attr_len);
    578                    }
    579                  }
    580                  else if (attr_value[0] == 'H'){
    581                      if(attr_value[1] == 'T'){
    582                      char array[40];
    583                      int index = 2;
    584                      int j = 0;
    585                      
    586                      while(attr_value[index] != '\n'){
    587                        array[j] = attr_value[index];
    588                        j++;
    589                        index++;
    590                      }
    591                        hhtimei = s2i(array);
    592                        send_times(bstimei, hhtimei);
    593                      
    594                    }
    595                      else if(attr_value[1] == 'E'){
    596                        char array[40];
    597                        array[0] = '0';
    598                        for(int index = 1; index <attr_len; index++){
    599                            array[index] = attr_value[index];
    600                            
    601                        }
    602                          processInputData(array, attr_len);
    603                      
    604                    }
    605                  }  
    606                  for(int i = 0; i < attr_len; i++) //Print out the received message
    607                    printf("%c",attr_value[i]);
    608                  printf("\r\n");
    609                  break;
    610                }
    611              }
    612          #endif
    613          }
    614          
    615          
    616          void send_times(){
    617            
    618            if((bstimei != 0) && (hhtimei != 0)){
    619              
    620              offsetp = calculate( bstimei,  hhtimei);
    621              
    622              bstimei = 0;
    623              hhtimei = 0;
    624              
    625              
    626              char number[6];
    627              sprintf(number, "%d", offsetp);
    628              char messageB[8];
    629              char messageH[8];
    630              messageB[0] = '0';
    631              messageH[0] = '1';
    632              messageB[1] = 'O';
    633              messageH[1] = 'O';
    634              int j = 2;
    635              for(int index = 0; index < 4; index++){
    636                messageB[j] = number[index];
    637                messageH[j] = number[index];
    638                j++;
    639              }
    640              messageB[6] = '\n';
    641              messageH[6] = '\n';
    642              messageB[7] = '\0';
    643              messageH[7] = '\0';
    644              processInputData(messageB, 8);
    645              processInputData(messageH, 8);
    646              
    647              
    648              
    649            } 
    650            
    651            
    652          }
    653          
    654          void User_Process(void)
    655          {
    656              if(arrayFlags[index].set_connectable){
    657                  Make_Connection();      //If devices need to be connected, connect them
    658                  changeFlag(CLEAR, &arrayFlags[index].set_connectable);        //Update connection flag status
    659              }
    660          
    661          #if REQUEST_CONN_PARAM_UPDATE    
    662              if(APP_FLAG(CONNECTED) && !APP_FLAG(L2CAP_PARAM_UPD_SENT) && Timer_Expired(&l2cap_req_timer)){
    663                  printf("got here\r\n");
    664                  aci_l2cap_connection_parameter_update_request(connection_handle, 8, 16, 0, 600);
    665                  APP_FLAG_SET(L2CAP_PARAM_UPD_SENT);
    666              }
    667          #endif
    668              
    669          #if CLIENT      //Each loop the flags are checked to see what needs to be done
    670                          //Things such as discovering the TX/RX characteristic handles and enabling notifications are done
    671              
    672              
    673              /* Start TX handle Characteristic discovery if not yet done */
    674              if (APP_FLAG(CONNECTED) && !arrayFlags[index].end_read_TX_char_handle)
    675              {
    676                if (!arrayFlags[index].start_read_TX_char_handle)
    677                {
    678                  /* Discovery TX characteristic handle by UUID 128 bits */
    679                  
    680                   const uint8_t charUuid128_TX[16] = {0x66,0x9a,0x0c,0x20,0x00,0x08,0x96,0x9e,0xe2,0x11,0x9e,0xb1,0xe1,0xf2,0x73,0xd9};
    681                   
    682                   aci_gatt_disc_charac_by_uuid(slaves[index].connection_handle, 0x0001, 0xFFFF,UUID_TYPE_128,
    683                                                             charUuid128_TX);
    684                   changeFlag(SET, &arrayFlags[index].start_read_TX_char_handle);
    685                }
    686              }
    687              /* Start RX handle Characteristic discovery if not yet done */
    688              else if (APP_FLAG(CONNECTED) && !arrayFlags[index].end_read_RX_char_handle)
    689              {
    690                //printf("Haven't finished reading RX handle");
    691                /* Discovery RX characteristic handle by UUID 128 bits */
    692                if (!arrayFlags[index].start_read_RX_char_handle)
    693                {
    694                  /* Discovery TX characteristic handle by UUID 128 bits */
    695                  //printf("attempting to read RX handle\r\n");
    696                   const uint8_t charUuid128_RX[16] = {0x66,0x9a,0x0c,0x20,0x00,0x08,0x96,0x9e,0xe2,0x11,0x9e,0xb1,0xe2,0xf2,0x73,0xd9};
    697                   aci_gatt_disc_charac_by_uuid(slaves[index].connection_handle, 0x0001, 0xFFFF,UUID_TYPE_128,
    698                                                             charUuid128_RX);
    699                   changeFlag(SET, &arrayFlags[index].start_read_RX_char_handle);
    700                 }
    701              }
    702              
    703              if(APP_FLAG(CONNECTED) && arrayFlags[index].end_read_TX_char_handle && arrayFlags[index].end_read_RX_char_handle && !arrayFlags[index].notifications_enabled){
    704                  uint8_t client_char_conf_data[] = {0x01, 0x00}; // Enable notifications
    705                  struct timer t;
    706                  Timer_Set(&t, CLOCK_SECOND*10);
    707                  
    708                  while(aci_gatt_write_charac_descriptor(slaves[index].connection_handle, slaves[index].tx_handle+2, 2, client_char_conf_data)==BLE_STATUS_NOT_ALLOWED){ //TX_HANDLE;
    709                      // Radio is busy.
    710                      if(Timer_Expired(&t)) break;
    711                  }
    712                  changeFlag(SET, &arrayFlags[index].notifications_enabled);
    713                }
    714              else if(APP_FLAG(CONNECTED) && arrayFlags[index].end_read_TX_char_handle && arrayFlags[index].end_read_RX_char_handle && arrayFlags[index].notifications_enabled){
    715                  int numdevices = sizeof(slaves)/sizeof(sDevice);
    716                  if(index < numdevices - 1)
    717                    index++;        
    718              }
    719          #endif
    720              
    721              
    722          #if THROUGHPUT_TEST && SERVER   //Used for throughput testing
    723              
    724              printf("Throughput test\r\n");
    725              static uint8_t test_done = FALSE;
    726              
    727              if(APP_FLAG(CONNECTED) && !test_done && APP_FLAG(NOTIFICATIONS_ENABLED)){
    728              
    729                  uint8_t data[20] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J'};
    730                  
    731                  static tClockTime time, time2;
    732                  time = Clock_Time();
    733                  
    734                  for(int i = 0; i < NUM_PACKETS; i++){
    735                      
    736                      struct timer t;
    737                      Timer_Set(&t, CLOCK_SECOND*10);
    738                                      
    739                      while(aci_gatt_update_char_value(chatServHandle, TXCharHandle, 0, 20, data)==BLE_STATUS_INSUFFICIENT_RESOURCES)
    740                      {
    741                        // Radio is busy (buffer full).
    742                        if(Timer_Expired(&t))
    743                            break;
    744                      }
    745                  
    746                  }
    747                  
    748                  time2 = Clock_Time();
    749                  tClockTime diff = time2-time;
    750                  printf("\n%d packets. Elapsed time: %d ms. App throughput: %.2f kbps.\n\r", NUM_PACKETS, diff, (float)NUM_PACKETS*20*8/diff);
    751                  
    752                  test_done = TRUE;
    753              }
    754          #endif
    755              
    756          }
    757          
    758          /**
    759            * @brief  This function is called whenever there is an ACI event to be processed.
    760            * @note   Inside this function each event must be identified and correctly
    761            *         parsed.
    762            * @param  pckt  Pointer to the ACI packet
    763            * @retval None
    764            */
    765          void HCI_Event_CB(void *pckt)   //This function is called when ACI events occur (such as when a connection is complete)
    766          {
    767              hci_uart_pckt *hci_pckt = pckt;
    768              hci_event_pckt *event_pckt = (hci_event_pckt*)hci_pckt->data;
    769              
    770              if(hci_pckt->type != HCI_EVENT_PKT)
    771                  return;
    772              
    773              switch(event_pckt->evt){
    774                  
    775              case EVT_DISCONN_COMPLETE:
    776                  {
    777                      GAP_DisconnectionComplete_CB();
    778                  }
    779                  break;
    780                  
    781              case EVT_LE_META_EVENT:
    782                  {
    783                      evt_le_meta_event *evt = (void *)event_pckt->data;
    784                      
    785                      switch(evt->subevent){
    786                      case EVT_LE_CONN_COMPLETE:
    787                          {
    788                              evt_le_connection_complete *cc = (void *)evt->data;
    789                              GAP_ConnectionComplete_CB(cc->peer_bdaddr, cc->handle);
    790                          }
    791                          break;
    792                      }
    793                  }
    794                  break;
    795                  
    796              case EVT_VENDOR:
    797                  {
    798                      evt_blue_aci *blue_evt = (void*)event_pckt->data;
    799                      switch(blue_evt->ecode){
    800                          
    801                      case EVT_BLUE_GATT_ATTRIBUTE_MODIFIED:
    802                          {
    803                              evt_gatt_attr_modified *evt = (evt_gatt_attr_modified*)blue_evt->data;
    804                              Attribute_Modified_CB(evt->attr_handle, evt->data_length, evt->att_data);                    
    805                          }
    806                          break;
    807                      case EVT_BLUE_GATT_NOTIFICATION:
    808                          {
    809                              evt_gatt_attr_notification *evt = (evt_gatt_attr_notification*)blue_evt->data;
    810                              GATT_Notification_CB(evt->attr_handle, evt->event_data_length - 2, evt->attr_value);
    811                          }
    812                          break;
    813                       case EVT_BLUE_L2CAP_CONN_UPD_RESP:
    814                          {
    815                              evt_l2cap_conn_upd_resp *resp = (void*)blue_evt->data;
    816                              if(resp->result){
    817                                  PRINTF("> Connection parameters rejected.\n");
    818                              }
    819                              else{
    820                                  PRINTF("> Connection parameters accepted.\n");
    821                              }
    822                          }
    823                          break;
    824          #ifdef CLIENT            
    825                        case EVT_BLUE_GATT_DISC_READ_CHAR_BY_UUID_RESP:
    826                          {
    827                              evt_gatt_disc_read_char_by_uuid_resp *resp = (void*)blue_evt->data;
    828                              
    829                              if (arrayFlags[index].start_read_TX_char_handle && !arrayFlags[index].end_read_TX_char_handle)
    830                              {
    831                                slaves[index].tx_handle = resp->attr_handle;
    832                                PRINTF("Device %d TX Char Handle: %04X\n\r", index, slaves[index].tx_handle);
    833                              }
    834                              else if (arrayFlags[index].start_read_RX_char_handle && !arrayFlags[index].end_read_RX_char_handle)
    835                              {
    836                                slaves[index].rx_handle = resp->attr_handle;
    837                                PRINTF("Device %d RX Char Handle: %04X\n\r", index, slaves[index].rx_handle);
    838                              }
    839                          }
    840                          break;  
    841                          
    842                          case EVT_BLUE_GATT_PROCEDURE_COMPLETE:
    843                          {
    844                            /* Wait for gatt procedure complete event trigger related to Discovery Charac by UUID */
    845                            //evt_gatt_procedure_complete *pr = (void*)blue_evt->data;
    846                            
    847                            if (arrayFlags[index].start_read_TX_char_handle && !arrayFlags[index].end_read_TX_char_handle)
    848                            {
    849                              changeFlag(SET, &arrayFlags[index].end_read_TX_char_handle);
    850                              //printf("tried to set TX flag\r\nTX flag is %d\r\n",arrayFlags[index].end_read_TX_char_handle);
    851                            }
    852                            else if (arrayFlags[index].start_read_RX_char_handle && !arrayFlags[index].end_read_RX_char_handle)
    853                            {
    854                              changeFlag(SET, &arrayFlags[index].end_read_RX_char_handle);
    855                            }
    856                          }
    857                          break;
    858                          
    859                          case EVT_BLUE_GAP_PROCEDURE_COMPLETE:
    860                          {
    861                            flag_scan_complete = 1;
    862                          }
    863                          break;
    864          #endif         
    865                      }
    866                  }
    867                  break;
    868              }
    869              
    870          }
    871          
    872          
    873          #ifdef USE_FULL_ASSERT
    874          /*******************************************************************************
    875          * Function Name  : assert_failed
    876          * Description    : Reports the name of the source file and the source line number
    877          *                  where the assert_param error has occurred.
    878          * Input          : - file: pointer to the source file name
    879          *                  - line: assert_param error line source number
    880          * Output         : None
    881          * Return         : None
    882          *******************************************************************************/
    883          void assert_failed(uint8_t* file, uint32_t line)
    884          {
    885              /* User can add his own implementation to report the file name and line number,
    886              ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
    887              
    888              /* Infinite loop */
    889              while (1)
    890              {
    891                printf("\r\nFailed\r\n");
    892                Clock_Wait(10000);
    893              }
    894          }
    895          #endif
    896          
    897          /******************* (C) COPYRIGHT 2014 STMicroelectronics *****END OF FILE****/
    898          /** \endcond
    899           */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   GAP_ConnectionComplete_CB
         0   -> printf
        16   -> printf
        16   -> turnLED
       8   GAP_DisconnectionComplete_CB
         8   -> printf
         8   -> turnLED
      56   GATT_Notification_CB
        56   -> printf
        56   -> processInputData
        56   -> s2i
        56   -> send_times
       8   HCI_Event_CB
         0   -> Attribute_Modified_CB
         0   -> GAP_ConnectionComplete_CB
         0   -> GAP_DisconnectionComplete_CB
         0   -> GATT_Notification_CB
         0   -> changeFlag
         0   -> printf
      40   Make_Connection
        40   -> Clock_Wait
        40   -> HCI_Process
        40   -> aci_gap_create_connection
        40   -> printf
      40   User_Process
        40   -> Make_Connection
        40   -> Timer_Expired
        40   -> Timer_Set
        40   -> aci_gatt_disc_charac_by_uuid
        40   -> aci_gatt_write_charac_descriptor
        40   -> changeFlag
      40   main
        40   -> BlueNRG_RST
        40   -> Clock_Init
        40   -> Clock_Time
        40   -> Clock_Wait
        40   -> FLASH_SLEEPPowerDownCmd
        40   -> HCI_Init
        40   -> HCI_Process
        40   -> Init_GPIOs
        40   -> NVIC_PriorityGroupConfig
        40   -> NVIC_SetVectorTable
        40   -> PWR_FastWakeUpCmd
        40   -> PWR_PVDCmd
        40   -> PWR_UltraLowPowerCmd
        40   -> RCC_Configuration
        40   -> SdkEvalGetVersion
        40   -> SdkEvalIdentification
        40   -> SdkEvalSpiInit
        40   -> SdkEval_IO_Config
        40   -> User_Process
        40   -> aci_gap_init
        40   -> aci_gap_set_auth_requirement
        40   -> aci_gatt_init
        40   -> aci_hal_set_tx_power_level
        40   -> aci_hal_write_config_data
        40   -> enableTimerInterrupt
        40   -> initButton
        40   -> initDevices
        40   -> initLED
        40   -> initTimer
        40   -> printf
        40   -> startTimer
      32   send_times
        32   -> calculate
        32   -> processInputData
        32   -> sprintf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable30
       4  ??DataTable33
       4  ??DataTable33_1
       4  ??DataTable33_2
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable34_2
       4  ??DataTable34_3
       4  ??DataTable34_4
       4  ??DataTable34_5
       4  ??DataTable34_6
       4  ??DataTable34_7
       2  ?_0
       8  ?_1
      48  ?_10
      36  ?_11
      16  ?_12
       8  ?_13
       8  ?_14
      16  ?_15
      16  ?_16
       4  ?_17
       4  ?_18
       4  ?_19
       1  ?_2
      16  ?_20
      16  ?_21
       2  ?_22
      36  ?_23
      36  ?_24
      36  ?_25
      36  ?_26
      36  ?_3
      28  ?_4
      20  ?_5
      20  ?_6
      28  ?_7
      48  ?_8
      12  ?_9
     140  GAP_ConnectionComplete_CB
      86  GAP_DisconnectionComplete_CB
     360  GATT_Notification_CB
     410  HCI_Event_CB
     102  Make_Connection
     410  User_Process
      16  app_flags
          flag_scan_complete
          flag_connection_complete
          index
      12  bstimei
          hhtimei
          offsetp
       2  connection_handle
       8  l2cap_req_timer
     432  main
       2  rx_handle
     132  send_times
       2  tx_handle

 
    26 bytes in section .bss
    16 bytes in section .data
    14 bytes in section .rodata
 2 647 bytes in section .text
 
 2 647 bytes of CODE  memory
    14 bytes of CONST memory
    42 bytes of DATA  memory

Errors: none
Warnings: 9
