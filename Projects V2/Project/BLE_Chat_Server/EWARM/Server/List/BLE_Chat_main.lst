###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        18/Mar/2015  15:38:36
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\src\BLE_Chat_main.c
#    Command line =  
#        "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\src\BLE_Chat_main.c" -D
#        USE_STDPERIPH_DRIVER -D STM32L1XX_MD -D SYSCLK_FREQ_HSI_32MHz -D
#        ENABLE_USB -D ENABLE_USB_PRINTF -D SERVER=1 -lcN "C:\School\2014
#        Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\Server\List\" --diag_suppress Pa050
#        -o "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\Server\Obj\" --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "C:\School\2014 Fall\ECE
#        4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\inc\" -I "C:\School\2014 Fall\ECE
#        4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\Bluetooth
#        LE\SimpleBlueNRG_HCI\" -I "C:\School\2014 Fall\ECE 4900\Bluetooth
#        Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\Bluetooth
#        LE\SimpleBlueNRG_HCI\includes\" -I "C:\School\2014 Fall\ECE
#        4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\" -I
#        "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32_USB-FS-Device_Driver\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32L1xx_StdPeriph_Driver\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\I2C\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\LIS3DH\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\STLM75\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\HTS221\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\LPS25H\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\SDK_Eval_STM32L\inc\"
#        -Ohs --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\Server\List\BLE_Chat_main.lst
#    Object file  =  
#        C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\Server\Obj\BLE_Chat_main.o
#
###############################################################################

C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects V2\Project\BLE_Chat_Server\src\BLE_Chat_main.c
      1          /******************** (C) COPYRIGHT 2014 STMicroelectronics ********************
      2          * File Name          : BLE_Chat_main.c
      3          * Author             : AMS - AAS Division
      4          * Version            : V1.0.1
      5          * Date               : 10-February-2014
      6          * Description        : BlueNRG main file for Chat demo
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          /**
     16           * @file  BLE_Chat_main.c
     17           * @brief This is a Chat demo that shows how to implement a simple 2-way communication between two BlueNRG devices.
     18           *
     19           * <!-- Copyright 2014 by STMicroelectronics.  All rights reserved.       *80*-->
     20          
     21          * \section IAR_project IAR project
     22            To use the project with IAR Embedded Workbench for ARM, please follow the instructions below:
     23            -# Open the Embedded Workbench for ARM.
     24            -# From the File->Open->Workspace menu, open the IAR workspace
     25               <tt> ...\\Projects\\Project\\BLE_Chat\\EWARM\\BLE_Chat.eww </tt>
     26            -# Select desired configuration to build
     27            -# Select Project->Rebuild All. This will recompile and link the entire application
     28            -# To download the binary image, please connect STLink to JTAG connector  in your board (if available).
     29            -# Select Project->Download and Debug to download the related binary image.
     30            -# Alternatively, open the BlueNRG GUI, put the board in DFU mode and download the built binary image.
     31            -# Connect the application board to a PC USB port. Open a hyperterminal on the
     32               corresponding USB virtual COMx port with the configuration as described in \ref Serial_IO.
     33          
     34          * \subsection IAR_project_configurations IAR project configurations
     35          
     36            - \c Client - Client role configuration 
     37            - \c Server - Server role configuration
     38            - \c Client_throughput - Client role configuration for throughput test
     39            - \c Server_throughput - Server role configuration for throughput test
     40          
     41          * \section Prebuilt_images Prebuilt images
     42            - BLE_Chat_Client.hex, BLE_Chat_Server.hex 
     43           
     44          * \section Jumper_settings Jumper settings
     45          @table
     46          ------------------------------------------------------
     47          | Jumper name       |  Description                   | 
     48          ------------------------------------------------------
     49          | JP1, if available | USB or Battery supply position | 
     50          
     51          @endtable 
     52          
     53          
     54          * \section Board_supported Board supported
     55          @table
     56          | Board name      | Board revision | NOTE        |
     57          --------------------------------------------------
     58          | STEVAL-IDB002V1 | 3.0            | Eval Kit    |
     59          | STEVAL-IDB003V1 | 1.0            | USB Dongle  |
     60          @endtable
     61          
     62          * \section Serial_IO Serial I/O
     63            The application will listen for keys typed in one node and, on return press, it will send them to the remote node.
     64            The remote node will listen for RF messages and it will output them in the serial port.
     65            In other words everything typed in one node will be visible to the other node and viceversa.
     66          @table
     67          | Parameter name  | Value          | Unit        |
     68          --------------------------------------------------
     69          | Baudrate        | 115200         | bit/sec     |
     70          | Data bits       | 8              | bit         |
     71          | Parity          | None           | bit         |
     72          | Stop bits       | 1              | bit         |
     73          @endtable
     74          
     75          * \section LEDs_description LEDs description
     76          @table
     77          |                  | STEVAL-IDB002V1 | STEVAL-IDB003V1 |                 
     78          | LED name         | Client/Server   | Client/Server   | 
     79          --------------------------------------------------------
     80          | D1               | Not used        | NA              |        
     81          | D2               | Not used        | Not used        |     
     82          | D3               | Not used        | Not used        |     
     83          | D4               | Not used        | NA              |      
     84          | D5               | Not used        | NA              |       
     85          | D6               | Not used        | NA              |       
     86          @endtable
     87           - NA : Not Applicable;
     88          
     89          * \section Buttons_description Buttons description
     90          @table
     91          |                  | STEVAL-IDB002V1 | STEVAL-IDB003V1 |                 
     92          | Button name      | Client/Server   | Client/Server   | 
     93          --------------------------------------------------------
     94          | RESET            | X               | NA              |  
     95          | Push Button      | Not used        | NA              |   
     96          | Jostick Sel      | Not used        | NA              |    
     97          | SW1              | NA              | Not used        |     
     98          | SW2              | NA              | Not used        |       
     99          @endtable
    100           - NA : Not Applicable;
    101          
    102          * \section DFU_Activation  DFU activation
    103          BlueNRG boards are preprogrammed with a DFU application which allows to upload the 
    104          STM32L micro with a selected binary image through USB. Follow list of actions 
    105          for activating DFU on each supported platforms
    106          @table
    107          | Board  name          | Event                                             | Note               |
    108          ------------------------------------------------------------------------------------------------|
    109          | STEVAL-IDB002V1      | Press RESET and Push Button. Release RESET button | LED D2 is toggling |  
    110          | STEVAL-IDB003V1      | Press SW1 button and plug USB dongle on a PC port | LED D3 is toggling |  
    111          @endtable
    112          
    113          * \section Usage Usage
    114          
    115          This Chat demo has  are 2 roles:
    116           - The server that expose the Chat service. It is the slave.
    117           - The client that uses the Chat service. It is the master.
    118          
    119          The Chat Service contains 2 Characteristics:
    120           -# The TX Characteristic: the client can enable notifications on this characteristic. When the server has data to be sent, it will send notifications which will contains the value of the TX Characteristic
    121           -# The RX Characteristic: it is a writable caracteristic. When the client has data to be sent to the server, it will write a value into this characteristic.
    122          
    123          The maximum length of the characteristic value is 20 bytes.
    124          
    125          NOTES:
    126           - The Client_throughput and Server_throughput workspaces allow to target a throughput test (THROUGHPUT_TEST define on the preprocessor options on both workspaces).
    127           - Program the client on one BlueNRG platform and reset it. The platform will be seen on the PC as a virtual COM port. Open the port in a serial terminal emulator. Client will start 4 seconds after reset.
    128           - Program the server on a second BlueNRG platform and reset it. The two platforms will try to establish a connection. As soon as they get connected, the slave will 
    129             send notification to the client of 20 bytes (200 notifications). 
    130           - After all the notifications are received, the measured application throughput will be displayed.
    131          
    132          **/
    133          /** @addtogroup BlueNRG_demonstrations_applications
    134           * BlueNRG Chat demo \see BLE_Chat_main.c for documentation.
    135           *
    136           *@{
    137           */
    138          
    139          /** @} */
    140          /** \cond DOXYGEN_SHOULD_SKIP_THIS
    141           */
    142          /* Includes ------------------------------------------------------------------*/
    143          #include "stm32l1xx.h"
    144          #include "usb_lib.h"
    145          #include "hw_config.h"
    146          #include "hal_types.h"
    147          #include "hci.h"
    148          #include "bluenrg_aci.h"
    149          #include "gp_timer.h"
    150          #include "hal.h"
    151          #include "osal.h"
    152          #include "gatt_db.h"
    153          #include "gatt_server.h"
    154          #include "hci_const.h"
    155          #include "gap.h"
    156          #include "sm.h"
    157          #include "app_state.h"
    158          #include "led.h"
    159          #include "push_button.h"
    160          #include "timer.h"
    161          #include <stdio.h>
    162          //#include "syncr.h"
    163          
    164          #include "SDK_EVAL_Config.h"
    165          
    166          /* External variables --------------------------------------------------------*/
    167          /* Private typedef -----------------------------------------------------------*/
    168          /* Private defines -----------------------------------------------------------*/
    169          /** 
    170            * @brief  Enable debug printf's
    171            */ 
    172          #ifndef DEBUG
    173          #define DEBUG 1
    174          #endif
    175                
    176          #define REQUEST_CONN_PARAM_UPDATE 0
    177          
    178          /* Private macros ------------------------------------------------------------*/
    179          #if DEBUG
    180          #include <stdio.h>
    181          #define PRINTF(...) printf(__VA_ARGS__)
    182          #else
    183          #define PRINTF(...)
    184          #endif
    185          
    186          #define NUM_PACKETS 200 // Only used for throughput test (define THROUGHPUT_TEST)
    187          
    188          #ifndef VECTOR_TABLE_BASE_ADDRESS 
    189          /* default configuration: DFU upgrade is supported */
    190          #define VECTOR_TABLE_BASE_ADDRESS            (0x3000)
    191          #endif
    192          
    193          /* Private variables ---------------------------------------------------------*/
    194          volatile int app_flags = SET_CONNECTABLE;
    195          volatile uint16_t connection_handle = 0;
    196          extern uint16_t chatServHandle, TXCharHandle, RXCharHandle, syncReq = 0;
    197          struct timer l2cap_req_timer;
    198          //volatile int numConnected = 0;
    199          
    200          /** 
    201            * @brief  Handle of TX,RX  Characteristics.
    202            */ 
    203          
    204          #ifdef CLIENT
    205          uint16_t tx_handle;
    206          uint16_t rx_handle;
    207          #endif 
    208          
    209          
    210          /* Private function prototypes -----------------------------------------------*/
    211          void Make_Connection(void);
    212          void User_Process(void);
    213          
    214          
    215          /* Private functions ---------------------------------------------------------*/
    216          
    217          /*  User Function where serial received data should be processed */
    218          void processInputData(uint8_t * rx_data, uint16_t data_size);
    219          
    220          /*******************************************************************************
    221          * Function Name  : main.
    222          * Description    : Main routine.
    223          * Input          : None.
    224          * Output         : None.
    225          * Return         : None.
    226          *******************************************************************************/
    227          int main(void)
    228          {
    229              int ret;
    230              
    231              NVIC_SetVectorTable(NVIC_VectTab_FLASH, VECTOR_TABLE_BASE_ADDRESS);
    232              
    233              /* Identify BlueNRG platform */
    234              SdkEvalIdentification();
    235          
    236              RCC_Configuration();
    237              
    238              /* Init I/O ports */
    239              Init_GPIOs ();
    240              
    241              PWR_PVDCmd(DISABLE);
    242              
    243              /* Initialize LEDs */
    244              initLED(0);
    245              initLED(3);
    246              initLED(4);
    247              //initOffset();
    248              
    249              /* Initilize event */
    250              initTimer(2,1000);
    251              enableTimerInterrupt(2);
    252              initTimer(4,100);
    253              enableTimerInterrupt(4);
    254              initTimer(6,5000);
    255              enableTimerInterrupt(6);
    256              
    257              
    258              /* Disable FLASH during Sleep  */
    259              FLASH_SLEEPPowerDownCmd(ENABLE);
    260              
    261              /* Enable Ultra low power mode */
    262              PWR_UltraLowPowerCmd(ENABLE);
    263              
    264              PWR_FastWakeUpCmd(ENABLE);
    265              
    266              NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
    267              
    268              Clock_Init();
    269              
    270              /* Delay needed only to be able to acces the JTAG interface after reset
    271              if it will be disabled later. */
    272              Clock_Wait(500);    
    273              
    274              /* Configure I/O communication channel:
    275                 It requires the void IO_Receive_Data(uint8_t * rx_data, uint16_t data_size) function
    276                 where user received data should be processed */
    277              SdkEval_IO_Config(processInputData);
    278              
    279              /* Delay for debug purpose, in order to see printed data at startup. */
    280              for(int i = 0; i < 100 ; i++){
    281                  printf(".");
    282                  Clock_Wait(70);
    283              }
    284          
    285              HCI_Init();
    286              
    287              /* Init SPI interface */
    288              SdkEvalSpiInit(SPI_MODE_EXTI);
    289              BlueNRG_RST(); 
    290              
    291              {
    292          #if CLIENT
    293                  uint8_t bdaddr[] = {0xbb, 0x00, 0x00, 0xE1, 0x80, 0x02};
    294          #else
    295                  uint8_t bdaddr[] = {0xaa, 0x00, 0x00, 0xE1, 0x80, 0x02};
    296          #endif
    297                  ret = aci_hal_write_config_data(CONFIG_DATA_PUBADDR_OFFSET, CONFIG_DATA_PUBADDR_LEN,
    298                                                  bdaddr);
    299                  if(ret){
    300                      PRINTF("Setting BD_ADDR failed.\n");
    301                  }
    302              }
    303              
    304              ret = aci_gatt_init();    
    305              if(ret){
    306                  PRINTF("GATT_Init failed.\n");
    307              }
    308              
    309              {
    310                  uint16_t service_handle, dev_name_char_handle, appearance_char_handle;
    311          #if SERVER
    312                  ret = aci_gap_init(GAP_PERIPHERAL_ROLE, &service_handle, &dev_name_char_handle, &appearance_char_handle);
    313          #else
    314                  ret = aci_gap_init(GAP_CENTRAL_ROLE, &service_handle, &dev_name_char_handle, &appearance_char_handle);
    315          #endif
    316                  if(ret){
    317                      PRINTF("GAP_Init failed.\n");
    318                  }
    319              }
    320            
    321              /*ret = aci_gap_set_auth_requirement(MITM_PROTECTION_REQUIRED,
    322                                                 OOB_AUTH_DATA_ABSENT,
    323                                                 NULL,
    324                                                 7,
    325                                                 16,
    326                                                 USE_FIXED_PIN_FOR_PAIRING,       
    327                                                 123456,
    328                                                 BONDING);
    329              PRINTF("BLE Stack Initialized.\r\n");*/
    330              
    331          #if  SERVER
    332              PRINTF("SERVER: BLE Stack Initialized (platform: %d)\n\r", SdkEvalGetVersion());
    333              ret = Add_Chat_Service();
    334              
    335              if(ret == BLE_STATUS_SUCCESS)
    336                  PRINTF("Service added successfully.\r\n");
    337              else
    338                  PRINTF("Error while adding service.\r\n");
    339              
    340          #else
    341              PRINTF("CLIENT: BLE Stack Initialized  (platform: %d)\n\r", SdkEvalGetVersion());
    342          #endif 
    343              
    344              /* -2 dBm output power */
    345              ret = aci_hal_set_tx_power_level(1,4);
    346                  
    347              while(1)
    348              { 
    349                  HCI_Process();
    350                  User_Process();
    351                  //Clock_Wait(10000);
    352              }
    353          }
    354          
    355          /**
    356            * @brief  Make the device connectable
    357            * @param  None 
    358            * @retval None
    359            */
    360          void Make_Connection(void)
    361          {  
    362              tBleStatus ret;
    363              
    364              
    365          #if CLIENT
    366              tBDAddr bdaddr = {0xaa, 0x00, 0x00, 0xE1, 0x80, 0x02};
    367              
    368              //ret = aci_gap_create_connection(0x4000, 0x4000, PUBLIC_ADDR, bdaddr, PUBLIC_ADDR, 40, 40, 0, 60, 2000 , 2000); 
    369              ret = aci_gap_create_connection(0x4000, 0x4000, PUBLIC_ADDR, bdaddr, PUBLIC_ADDR, 9, 9, 0, 60, 1000 , 1000); 
    370              if (ret != 0){
    371                  PRINTF("Error while starting connection.\n");
    372                  Clock_Wait(100);        
    373          	}
    374          #else
    375              
    376              const char local_name[] = {AD_TYPE_COMPLETE_LOCAL_NAME,'B','l','u','e','N','R','G','_','C','h','a','t'};
    377              
    378              /* disable scan response */
    379              //hci_le_set_scan_resp_data(0,NULL);
    380              
    381              PRINTF("General Discoverable Mode ");
    382              ret = aci_gap_set_discoverable(ADV_IND, 0x00a0, 0x00a0, PUBLIC_ADDR, 0x00,
    383                                             13, local_name, 0, 0x0, 0, 0);
    384          
    385              PRINTF("%d\n\r",ret);
    386          #endif
    387          }
    388          
    389          /**
    390            * @brief  This function is called when there is a LE Connection Complete event.
    391            * @param  addr Address of peer device
    392            * @param  handle Connection handle
    393            * @retval None
    394            */
    395          void GAP_ConnectionComplete_CB(uint8_t addr[6], uint16_t handle)
    396          {    
    397              APP_FLAG_SET(CONNECTED); 
    398              connection_handle = handle;
    399              
    400              //Show connection with LED
    401              turnLED(3,ON);
    402              //numConnected += 1;
    403              //if(numConnected != 2)
    404                //APP_FLAG_SET(SET_CONNECTABLE);
    405              
    406              PRINTF("Connected to device:");
    407              for(int i = 5; i > 0; i--){
    408                  PRINTF("%02X-", addr[i]);
    409              }
    410              PRINTF("%02X\n\r", addr[0]);
    411              
    412          #if REQUEST_CONN_PARAM_UPDATE
    413              APP_FLAG_CLEAR(L2CAP_PARAM_UPD_SENT);
    414              Timer_Set(&l2cap_req_timer, CLOCK_SECOND*2);
    415          #endif
    416              
    417          }
    418          
    419          /**
    420            * @brief  This function is called when the peer device get disconnected.
    421            * @param  None 
    422            * @retval None
    423            */
    424          void GAP_DisconnectionComplete_CB(void)
    425          {
    426            //Turn off connection LED
    427            turnLED(3,OFF);
    428            //numConnected -+ 1;
    429              APP_FLAG_CLEAR(CONNECTED);
    430              PRINTF("Disconnected\n\r");
    431              /* Make the device connectable again. */
    432              APP_FLAG_SET(SET_CONNECTABLE);
    433              APP_FLAG_CLEAR(NOTIFICATIONS_ENABLED);
    434              
    435              APP_FLAG_CLEAR(START_READ_TX_CHAR_HANDLE);
    436              APP_FLAG_CLEAR(END_READ_TX_CHAR_HANDLE);
    437              APP_FLAG_CLEAR(START_READ_RX_CHAR_HANDLE); 
    438              APP_FLAG_CLEAR(END_READ_RX_CHAR_HANDLE); 
    439          }
    440          
    441          /**
    442            * @brief  This function is called when there is a notification from the sever.
    443            * @param  attr_handle Handle of the attribute
    444            * @param  attr_len    Length of attribute value in the notification
    445            * @param  attr_value  Attribute value in the notification
    446            * @retval None
    447            */
    448          void GATT_Notification_CB(uint16_t attr_handle, uint8_t attr_len, uint8_t *attr_value)
    449          {
    450          #if THROUGHPUT_TEST && CLIENT
    451              static tClockTime time, time2;
    452              static int packets=0;     
    453              
    454              if(attr_handle == tx_handle+1){ 
    455                  if(packets==0){
    456                      printf("Test start\n\r");
    457                      time = Clock_Time();
    458                  }
    459                  
    460                  for(int i = 0; i < attr_len; i++)
    461                      printf("%c", attr_value[i]);
    462                  
    463                  printf("[RX: %d]", packets);//TBR
    464                  
    465                  packets++;
    466                  
    467                  if(packets == NUM_PACKETS){
    468                      time2 = Clock_Time();
    469                      tClockTime diff = time2-time;
    470                      printf("\n%d packets. Elapsed time: %d ms. App throughput: %.2f kbps.\n\r", NUM_PACKETS, diff, (float)NUM_PACKETS*20*8/diff);
    471                  }        
    472                  
    473              }
    474          #elif CLIENT
    475              
    476              if(attr_handle == tx_handle+1){
    477                for(int i = 0; i < attr_len; i++)
    478                    printf("%c", attr_value[i]);
    479              }
    480          #endif
    481          }
    482          
    483          void User_Process(void)
    484          {
    485              if(APP_FLAG(SET_CONNECTABLE)){
    486                  Make_Connection();
    487                  APP_FLAG_CLEAR(SET_CONNECTABLE);
    488              }
    489          
    490          #if REQUEST_CONN_PARAM_UPDATE    
    491              if(APP_FLAG(CONNECTED) && !APP_FLAG(L2CAP_PARAM_UPD_SENT) && Timer_Expired(&l2cap_req_timer)){
    492                  aci_l2cap_connection_parameter_update_request(connection_handle, 8, 16, 0, 600);
    493                  APP_FLAG_SET(L2CAP_PARAM_UPD_SENT);
    494              }
    495          #endif
    496              
    497          #if CLIENT
    498              
    499              
    500              /* Start TX handle Characteristic discovery if not yet done */
    501              if (APP_FLAG(CONNECTED) && !APP_FLAG(END_READ_TX_CHAR_HANDLE))
    502              {
    503                if (!APP_FLAG(START_READ_TX_CHAR_HANDLE))
    504                {
    505                  /* Discovery TX characteristic handle by UUID 128 bits */
    506                  
    507                   const uint8_t charUuid128_TX[16] = {0x66,0x9a,0x0c,0x20,0x00,0x08,0x96,0x9e,0xe2,0x11,0x9e,0xb1,0xe1,0xf2,0x73,0xd9};
    508                   
    509                   aci_gatt_disc_charac_by_uuid(connection_handle, 0x0001, 0xFFFF,UUID_TYPE_128,
    510                                                             charUuid128_TX);
    511                   APP_FLAG_SET(START_READ_TX_CHAR_HANDLE);
    512                }
    513              }
    514              /* Start RX handle Characteristic discovery if not yet done */
    515              else if (APP_FLAG(CONNECTED) && !APP_FLAG(END_READ_RX_CHAR_HANDLE))
    516              {
    517                /* Discovery RX characteristic handle by UUID 128 bits */
    518                if (!APP_FLAG(START_READ_RX_CHAR_HANDLE))
    519                {
    520                  /* Discovery TX characteristic handle by UUID 128 bits */
    521                  
    522                   const uint8_t charUuid128_RX[16] = {0x66,0x9a,0x0c,0x20,0x00,0x08,0x96,0x9e,0xe2,0x11,0x9e,0xb1,0xe2,0xf2,0x73,0xd9};
    523                   aci_gatt_disc_charac_by_uuid(connection_handle, 0x0001, 0xFFFF,UUID_TYPE_128,
    524                                                             charUuid128_RX);
    525                   APP_FLAG_SET(START_READ_RX_CHAR_HANDLE);
    526                 }
    527              }
    528              
    529              if(APP_FLAG(CONNECTED) && APP_FLAG(END_READ_TX_CHAR_HANDLE) && APP_FLAG(END_READ_RX_CHAR_HANDLE) && !APP_FLAG(NOTIFICATIONS_ENABLED)){
    530                  uint8_t client_char_conf_data[] = {0x01, 0x00}; // Enable notifications
    531                  struct timer t;
    532                  Timer_Set(&t, CLOCK_SECOND*10);
    533                  
    534                  while(aci_gatt_write_charac_descriptor(connection_handle, tx_handle+2, 2, client_char_conf_data)==BLE_STATUS_NOT_ALLOWED){ //TX_HANDLE;
    535                      // Radio is busy.
    536                      if(Timer_Expired(&t)) break;
    537                  }
    538                  APP_FLAG_SET(NOTIFICATIONS_ENABLED);
    539                }
    540              else if(APP_FLAG(CONNECTED) && APP_FLAG(END_READ_TX_CHAR_HANDLE) && APP_FLAG(END_READ_RX_CHAR_HANDLE) && APP_FLAG(NOTIFICATIONS_ENABLED)){
    541                uint8_t data_buffer[] = {0x48,0x45,0x4c,0x4c,0x4f,0x0d};
    542                uint16_t Nb_bytes = 6;
    543                processInputData(data_buffer, Nb_bytes);
    544                Clock_Wait(1000);
    545                }
    546             
    547          #endif
    548              
    549              
    550          #if THROUGHPUT_TEST && SERVER
    551              
    552              
    553              static uint8_t test_done = FALSE;
    554              
    555              if(APP_FLAG(CONNECTED) && !test_done && APP_FLAG(NOTIFICATIONS_ENABLED)){
    556              
    557                  uint8_t data[20] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J'};
    558                  
    559                  static tClockTime time, time2;
    560                  time = Clock_Time();
    561                  
    562                  for(int i = 0; i < NUM_PACKETS; i++){
    563                      
    564                      struct timer t;
    565                      Timer_Set(&t, CLOCK_SECOND*10);
    566                                      
    567                      while(aci_gatt_update_char_value(chatServHandle, TXCharHandle, 0, 20, data)==BLE_STATUS_INSUFFICIENT_RESOURCES)
    568                      {
    569                        // Radio is busy (buffer full).
    570                        if(Timer_Expired(&t))
    571                            break;
    572                      }
    573                  
    574                  }
    575                  
    576                  time2 = Clock_Time();
    577                  tClockTime diff = time2-time;
    578                  printf("\n%d packets. Elapsed time: %d ms. App throughput: %.2f kbps.\n\r", NUM_PACKETS, diff, (float)NUM_PACKETS*20*8/diff);
    579                  
    580                  test_done = TRUE;
    581              }
    582          #endif
    583              
    584          }
    585          
    586          /**
    587            * @brief  This function is called whenever there is an ACI event to be processed.
    588            * @note   Inside this function each event must be identified and correctly
    589            *         parsed.
    590            * @param  pckt  Pointer to the ACI packet
    591            * @retval None
    592            */
    593          
    594          
    595          void HCI_Event_CB(void *pckt)
    596          {
    597              hci_uart_pckt *hci_pckt = pckt;
    598              hci_event_pckt *event_pckt = (hci_event_pckt*)hci_pckt->data;
    599              
    600              if(hci_pckt->type != HCI_EVENT_PKT)
    601                  return;
    602              
    603              switch(event_pckt->evt){
    604                  
    605              case EVT_DISCONN_COMPLETE:
    606                  {
    607                      GAP_DisconnectionComplete_CB();
    608                  }
    609                  break;
    610                  
    611              case EVT_LE_META_EVENT:
    612                  {
    613                      evt_le_meta_event *evt = (void *)event_pckt->data;
    614                      
    615                      switch(evt->subevent){
    616                      case EVT_LE_CONN_COMPLETE:
    617                          {
    618                              evt_le_connection_complete *cc = (void *)evt->data;
    619                              GAP_ConnectionComplete_CB(cc->peer_bdaddr, cc->handle);
    620                          }
    621                          break;
    622                      }
    623                  }
    624                  break;
    625                  
    626              case EVT_VENDOR:
    627                  {
    628                      evt_blue_aci *blue_evt = (void*)event_pckt->data;
    629                      switch(blue_evt->ecode){
    630                          
    631                      case EVT_BLUE_GATT_ATTRIBUTE_MODIFIED:
    632                          {
    633                              evt_gatt_attr_modified *evt = (evt_gatt_attr_modified*)blue_evt->data;
    634                              Attribute_Modified_CB(evt->attr_handle, evt->data_length, evt->att_data);
    635                              
    636                              //Catch event
    637                              GPIO_ToggleBits(GPIOC,LED0);
    638                              uint16_t defined_hex = 0x45;
    639                              uint16_t handle = evt->attr_handle;
    640                              uint8_t data_length = evt->data_length;
    641                              uint8_t *att_data = evt->att_data;
    642                              if(handle == RXCharHandle + 1){
    643                                if(att_data[0] == defined_hex){
    644                                  // call function
    645                                   startTimer(2);
    646                                 }
    647                                 //Clock_Wait(100);
    648                                 //att_data[0] = att_data[0]+1;
    649                                 //processInputData(att_data, data_length);
    650                              }
    651                              
    652                          }
    653                          break;
    654                      case EVT_BLUE_GATT_NOTIFICATION:
    655                          {
    656                              evt_gatt_attr_notification *evt = (evt_gatt_attr_notification*)blue_evt->data;
    657                              GATT_Notification_CB(evt->attr_handle, evt->event_data_length - 2, evt->attr_value);
    658                          }
    659                          break;
    660                       case EVT_BLUE_L2CAP_CONN_UPD_RESP:
    661                          {
    662                              evt_l2cap_conn_upd_resp *resp = (void*)blue_evt->data;
    663                              if(resp->result){
    664                                  PRINTF("> Connection parameters rejected.\n");
    665                              }
    666                              else{
    667                                  PRINTF("> Connection parameters accepted.\n");
    668                              }
    669                          }
    670                          break;
    671          #ifdef CLIENT            
    672                        case EVT_BLUE_GATT_DISC_READ_CHAR_BY_UUID_RESP:
    673                          {
    674                              evt_gatt_disc_read_char_by_uuid_resp *resp = (void*)blue_evt->data;
    675                              
    676                              if (APP_FLAG(START_READ_TX_CHAR_HANDLE) && !APP_FLAG(END_READ_TX_CHAR_HANDLE))
    677                              {
    678                                tx_handle = resp->attr_handle;
    679                                PRINTF("TX Char Handle %04X\n\r", tx_handle);
    680                              }
    681                              else if (APP_FLAG(START_READ_RX_CHAR_HANDLE) && !APP_FLAG(END_READ_RX_CHAR_HANDLE))
    682                              {
    683                                rx_handle = resp->attr_handle;
    684                                PRINTF("RX Char Handle %04X\n\r", rx_handle);
    685                              }
    686                          }
    687                          break;  
    688                          
    689                          case EVT_BLUE_GATT_PROCEDURE_COMPLETE:
    690                          {
    691                            /* Wait for gatt procedure complete event trigger related to Discovery Charac by UUID */
    692                            //evt_gatt_procedure_complete *pr = (void*)blue_evt->data;
    693                            
    694                            if (APP_FLAG(START_READ_TX_CHAR_HANDLE) && !APP_FLAG(END_READ_TX_CHAR_HANDLE))
    695                            {
    696                              APP_FLAG_SET(END_READ_TX_CHAR_HANDLE);
    697                            }
    698                            else if (APP_FLAG(START_READ_RX_CHAR_HANDLE) && !APP_FLAG(END_READ_RX_CHAR_HANDLE))
    699                            {
    700                              APP_FLAG_SET(END_READ_RX_CHAR_HANDLE);
    701                            }
    702                          }
    703                          break;
    704          #endif         
    705                      }
    706                  }
    707                  break;
    708              }
    709              
    710          }
    711          
    712          
    713          #ifdef USE_FULL_ASSERT
    714          /*******************************************************************************
    715          * Function Name  : assert_failed
    716          * Description    : Reports the name of the source file and the source line number
    717          *                  where the assert_param error has occurred.
    718          * Input          : - file: pointer to the source file name
    719          *                  - line: assert_param error line source number
    720          * Output         : None
    721          * Return         : None
    722          *******************************************************************************/
    723          void assert_failed(uint8_t* file, uint32_t line)
    724          {
    725              /* User can add his own implementation to report the file name and line number,
    726              ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
    727              
    728              /* Infinite loop */
    729              while (1)
    730              {
    731                printf("\r\nFailed\r\n");
    732                Clock_Wait(10000);
    733              }
    734          }
    735          
    736          #endif
    737          
    738          /******************* (C) COPYRIGHT 2014 STMicroelectronics *****END OF FILE****/
    739          /** \endcond
    740           */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   GAP_ConnectionComplete_CB
         0   -> printf
        16   -> printf
        16   -> turnLED
       8   GAP_DisconnectionComplete_CB
         8   -> printf
         8   -> turnLED
       0   GATT_Notification_CB
       8   HCI_Event_CB
         8   -> Attribute_Modified_CB
         0   -> GAP_ConnectionComplete_CB
         0   -> GAP_DisconnectionComplete_CB
         8   -> GPIO_ToggleBits
         0   -> printf
         0   -> startTimer
      56   Make_Connection
        56   -> aci_gap_set_discoverable
        56   -> printf
      64   User_Process
        64   -> aci_gap_set_discoverable
        64   -> printf
      64   main
        64   -> Add_Chat_Service
        64   -> BlueNRG_RST
        64   -> Clock_Init
        64   -> Clock_Wait
        64   -> FLASH_SLEEPPowerDownCmd
        64   -> HCI_Init
        64   -> HCI_Process
        64   -> Init_GPIOs
        64   -> NVIC_PriorityGroupConfig
        64   -> NVIC_SetVectorTable
        64   -> PWR_FastWakeUpCmd
        64   -> PWR_PVDCmd
        64   -> PWR_UltraLowPowerCmd
        64   -> RCC_Configuration
        64   -> SdkEvalGetVersion
        64   -> SdkEvalIdentification
        64   -> SdkEvalSpiInit
        64   -> SdkEval_IO_Config
        64   -> aci_gap_init
        64   -> aci_gap_set_discoverable
        64   -> aci_gatt_init
        64   -> aci_hal_set_tx_power_level
        64   -> aci_hal_write_config_data
        64   -> enableTimerInterrupt
        64   -> initLED
        64   -> initTimer
        64   -> printf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable21_4
       2  ?_0
       8  ?_1
       8  ?_10
      24  ?_11
       8  ?_12
       8  ?_13
      16  ?_14
      36  ?_15
      36  ?_16
      28  ?_2
      20  ?_3
      20  ?_4
      48  ?_5
      32  ?_6
      32  ?_7
      16  ?_8
      28  ?_9
      94  GAP_ConnectionComplete_CB
      78  GAP_DisconnectionComplete_CB
       2  GATT_Notification_CB
     148  HCI_Event_CB
      68  Make_Connection
      84  User_Process
       8  connection_handle
          app_flags
       8  l2cap_req_timer
     378  main
       2  syncReq

 
    10 bytes in section .bss
     8 bytes in section .data
     2 bytes in section .rodata
 1 240 bytes in section .text
 
 1 240 bytes of CODE  memory
     2 bytes of CONST memory
    18 bytes of DATA  memory

Errors: none
Warnings: 1
