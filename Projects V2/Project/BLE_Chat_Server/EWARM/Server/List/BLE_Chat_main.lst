###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        06/Mar/2015  09:41:00
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\src\BLE_Chat_main.c
#    Command line =  
#        "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\src\BLE_Chat_main.c" -D
#        USE_STDPERIPH_DRIVER -D STM32L1XX_MD -D SYSCLK_FREQ_HSI_32MHz -D
#        ENABLE_USB -D ENABLE_USB_PRINTF -D SERVER=1 -lcN "C:\School\2014
#        Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\Server\List\" --diag_suppress Pa050
#        -o "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\Server\Obj\" --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "C:\School\2014 Fall\ECE
#        4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\inc\" -I "C:\School\2014 Fall\ECE
#        4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\Bluetooth
#        LE\SimpleBlueNRG_HCI\" -I "C:\School\2014 Fall\ECE 4900\Bluetooth
#        Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\Bluetooth
#        LE\SimpleBlueNRG_HCI\includes\" -I "C:\School\2014 Fall\ECE
#        4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\" -I
#        "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32_USB-FS-Device_Driver\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32L1xx_StdPeriph_Driver\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\I2C\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\LIS3DH\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\STLM75\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\HTS221\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\LPS25H\inc\"
#        -I "C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\SDK_Eval_STM32L\inc\"
#        -Ohs --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\Server\List\BLE_Chat_main.lst
#    Object file  =  
#        C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects
#        V2\Project\BLE_Chat_Server\EWARM\Server\Obj\BLE_Chat_main.o
#
###############################################################################

C:\School\2014 Fall\ECE 4900\Bluetooth Code\SVN\trunk\Projects V2\Project\BLE_Chat_Server\src\BLE_Chat_main.c
      1          /******************** (C) COPYRIGHT 2014 STMicroelectronics ********************
      2          * File Name          : BLE_Chat_main.c
      3          * Author             : AMS - AAS Division
      4          * Version            : V1.0.1
      5          * Date               : 10-February-2014
      6          * Description        : BlueNRG main file for Chat demo
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          /**
     16           * @file  BLE_Chat_main.c
     17           * @brief This is a Chat demo that shows how to implement a simple 2-way communication between two BlueNRG devices.
     18           *
     19           * <!-- Copyright 2014 by STMicroelectronics.  All rights reserved.       *80*-->
     20          
     21          * \section IAR_project IAR project
     22            To use the project with IAR Embedded Workbench for ARM, please follow the instructions below:
     23            -# Open the Embedded Workbench for ARM.
     24            -# From the File->Open->Workspace menu, open the IAR workspace
     25               <tt> ...\\Projects\\Project\\BLE_Chat\\EWARM\\BLE_Chat.eww </tt>
     26            -# Select desired configuration to build
     27            -# Select Project->Rebuild All. This will recompile and link the entire application
     28            -# To download the binary image, please connect STLink to JTAG connector  in your board (if available).
     29            -# Select Project->Download and Debug to download the related binary image.
     30            -# Alternatively, open the BlueNRG GUI, put the board in DFU mode and download the built binary image.
     31            -# Connect the application board to a PC USB port. Open a hyperterminal on the
     32               corresponding USB virtual COMx port with the configuration as described in \ref Serial_IO.
     33          
     34          * \subsection IAR_project_configurations IAR project configurations
     35          
     36            - \c Client - Client role configuration 
     37            - \c Server - Server role configuration
     38            - \c Client_throughput - Client role configuration for throughput test
     39            - \c Server_throughput - Server role configuration for throughput test
     40          
     41          * \section Prebuilt_images Prebuilt images
     42            - BLE_Chat_Client.hex, BLE_Chat_Server.hex 
     43           
     44          * \section Jumper_settings Jumper settings
     45          @table
     46          ------------------------------------------------------
     47          | Jumper name       |  Description                   | 
     48          ------------------------------------------------------
     49          | JP1, if available | USB or Battery supply position | 
     50          
     51          @endtable 
     52          
     53          
     54          * \section Board_supported Board supported
     55          @table
     56          | Board name      | Board revision | NOTE        |
     57          --------------------------------------------------
     58          | STEVAL-IDB002V1 | 3.0            | Eval Kit    |
     59          | STEVAL-IDB003V1 | 1.0            | USB Dongle  |
     60          @endtable
     61          
     62          * \section Serial_IO Serial I/O
     63            The application will listen for keys typed in one node and, on return press, it will send them to the remote node.
     64            The remote node will listen for RF messages and it will output them in the serial port.
     65            In other words everything typed in one node will be visible to the other node and viceversa.
     66          @table
     67          | Parameter name  | Value          | Unit        |
     68          --------------------------------------------------
     69          | Baudrate        | 115200         | bit/sec     |
     70          | Data bits       | 8              | bit         |
     71          | Parity          | None           | bit         |
     72          | Stop bits       | 1              | bit         |
     73          @endtable
     74          
     75          * \section LEDs_description LEDs description
     76          @table
     77          |                  | STEVAL-IDB002V1 | STEVAL-IDB003V1 |                 
     78          | LED name         | Client/Server   | Client/Server   | 
     79          --------------------------------------------------------
     80          | D1               | Not used        | NA              |        
     81          | D2               | Not used        | Not used        |     
     82          | D3               | Not used        | Not used        |     
     83          | D4               | Not used        | NA              |      
     84          | D5               | Not used        | NA              |       
     85          | D6               | Not used        | NA              |       
     86          @endtable
     87           - NA : Not Applicable;
     88          
     89          * \section Buttons_description Buttons description
     90          @table
     91          |                  | STEVAL-IDB002V1 | STEVAL-IDB003V1 |                 
     92          | Button name      | Client/Server   | Client/Server   | 
     93          --------------------------------------------------------
     94          | RESET            | X               | NA              |  
     95          | Push Button      | Not used        | NA              |   
     96          | Jostick Sel      | Not used        | NA              |    
     97          | SW1              | NA              | Not used        |     
     98          | SW2              | NA              | Not used        |       
     99          @endtable
    100           - NA : Not Applicable;
    101          
    102          * \section DFU_Activation  DFU activation
    103          BlueNRG boards are preprogrammed with a DFU application which allows to upload the 
    104          STM32L micro with a selected binary image through USB. Follow list of actions 
    105          for activating DFU on each supported platforms
    106          @table
    107          | Board  name          | Event                                             | Note               |
    108          ------------------------------------------------------------------------------------------------|
    109          | STEVAL-IDB002V1      | Press RESET and Push Button. Release RESET button | LED D2 is toggling |  
    110          | STEVAL-IDB003V1      | Press SW1 button and plug USB dongle on a PC port | LED D3 is toggling |  
    111          @endtable
    112          
    113          * \section Usage Usage
    114          
    115          This Chat demo has  are 2 roles:
    116           - The server that expose the Chat service. It is the slave.
    117           - The client that uses the Chat service. It is the master.
    118          
    119          The Chat Service contains 2 Characteristics:
    120           -# The TX Characteristic: the client can enable notifications on this characteristic. When the server has data to be sent, it will send notifications which will contains the value of the TX Characteristic
    121           -# The RX Characteristic: it is a writable caracteristic. When the client has data to be sent to the server, it will write a value into this characteristic.
    122          
    123          The maximum length of the characteristic value is 20 bytes.
    124          
    125          NOTES:
    126           - The Client_throughput and Server_throughput workspaces allow to target a throughput test (THROUGHPUT_TEST define on the preprocessor options on both workspaces).
    127           - Program the client on one BlueNRG platform and reset it. The platform will be seen on the PC as a virtual COM port. Open the port in a serial terminal emulator. Client will start 4 seconds after reset.
    128           - Program the server on a second BlueNRG platform and reset it. The two platforms will try to establish a connection. As soon as they get connected, the slave will 
    129             send notification to the client of 20 bytes (200 notifications). 
    130           - After all the notifications are received, the measured application throughput will be displayed.
    131          
    132          **/
    133          /** @addtogroup BlueNRG_demonstrations_applications
    134           * BlueNRG Chat demo \see BLE_Chat_main.c for documentation.
    135           *
    136           *@{
    137           */
    138          
    139          /** @} */
    140          /** \cond DOXYGEN_SHOULD_SKIP_THIS
    141           */
    142          /* Includes ------------------------------------------------------------------*/
    143          #include "stm32l1xx.h"
    144          #include "usb_lib.h"
    145          #include "hw_config.h"
    146          #include "hal_types.h"
    147          #include "hci.h"
    148          #include "bluenrg_aci.h"
    149          #include "gp_timer.h"
    150          #include "hal.h"
    151          #include "osal.h"
    152          #include "gatt_db.h"
    153          #include "gatt_server.h"
    154          #include "hci_const.h"
    155          #include "gap.h"
    156          #include "sm.h"
    157          #include "app_state.h"
    158          #include "led.h"
    159          #include "push_button.h"
    160          #include "timer.h"
    161          #include <stdio.h>
    162          #include "syncr.h"
    163          
    164          #include "SDK_EVAL_Config.h"
    165          
    166          /* External variables --------------------------------------------------------*/
    167          /* Private typedef -----------------------------------------------------------*/
    168          /* Private defines -----------------------------------------------------------*/
    169          /** 
    170            * @brief  Enable debug printf's
    171            */ 
    172          #ifndef DEBUG
    173          #define DEBUG 1
    174          #endif
    175                
    176          #define REQUEST_CONN_PARAM_UPDATE 0
    177          
    178          /* Private macros ------------------------------------------------------------*/
    179          #if DEBUG
    180          #include <stdio.h>
    181          #define PRINTF(...) printf(__VA_ARGS__)
    182          #else
    183          #define PRINTF(...)
    184          #endif
    185          
    186          #define NUM_PACKETS 200 // Only used for throughput test (define THROUGHPUT_TEST)
    187          
    188          #ifndef VECTOR_TABLE_BASE_ADDRESS 
    189          /* default configuration: DFU upgrade is supported */
    190          #define VECTOR_TABLE_BASE_ADDRESS            (0x3000)
    191          #endif
    192          
    193          /* Private variables ---------------------------------------------------------*/
    194          volatile int app_flags = SET_CONNECTABLE;
    195          volatile uint16_t connection_handle = 0;
    196          extern uint16_t chatServHandle, TXCharHandle, RXCharHandle;
    197          struct timer l2cap_req_timer;
    198          //volatile int numConnected = 0;
    199          
    200          /** 
    201            * @brief  Handle of TX,RX  Characteristics.
    202            */ 
    203          #ifdef CLIENT
    204          uint16_t tx_handle;
    205          uint16_t rx_handle;
    206          #endif 
    207          
    208          
    209          /* Private function prototypes -----------------------------------------------*/
    210          void Make_Connection(void);
    211          void User_Process(void);
    212          
    213          /* Private functions ---------------------------------------------------------*/
    214          
    215          /*  User Function where serial received data should be processed */
    216          void processInputData(uint8_t * rx_data, uint16_t data_size);
    217          
    218          /*******************************************************************************
    219          * Function Name  : main.
    220          * Description    : Main routine.
    221          * Input          : None.
    222          * Output         : None.
    223          * Return         : None.
    224          *******************************************************************************/
    225          int main(void)
    226          {
    227              int ret;
    228              
    229              NVIC_SetVectorTable(NVIC_VectTab_FLASH, VECTOR_TABLE_BASE_ADDRESS);
    230              
    231              /* Identify BlueNRG platform */
    232              SdkEvalIdentification();
    233          
    234              RCC_Configuration();
    235              
    236              /* Init I/O ports */
    237              Init_GPIOs ();
    238              
    239              PWR_PVDCmd(DISABLE);
    240              
    241              /* Initialize LEDs */
    242              initLED(0);
    243              initLED(3);
    244              initLED(4);
    245              
    246              /* Initilize event */
    247              initTimer(2,1000);
    248              enableTimerInterrupt(2);
    249              initTimer(4,100);
    250              enableTimerInterrupt(4);
    251              initTimer(6,5000);
    252              enableTimerInterrupt(6);
    253              
    254              
    255              /* Disable FLASH during Sleep  */
    256              FLASH_SLEEPPowerDownCmd(ENABLE);
    257              
    258              /* Enable Ultra low power mode */
    259              PWR_UltraLowPowerCmd(ENABLE);
    260              
    261              PWR_FastWakeUpCmd(ENABLE);
    262              
    263              NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
    264              
    265              Clock_Init();
    266              
    267              /* Delay needed only to be able to acces the JTAG interface after reset
    268              if it will be disabled later. */
    269              Clock_Wait(500);    
    270              
    271              /* Configure I/O communication channel:
    272                 It requires the void IO_Receive_Data(uint8_t * rx_data, uint16_t data_size) function
    273                 where user received data should be processed */
    274              SdkEval_IO_Config(processInputData);
    275              
    276              /* Delay for debug purpose, in order to see printed data at startup. */
    277              for(int i = 0; i < 100 ; i++){
    278                  printf(".");
    279                  Clock_Wait(70);
    280              }
    281          
    282              HCI_Init();
    283              
    284              /* Init SPI interface */
    285              SdkEvalSpiInit(SPI_MODE_EXTI);
    286              BlueNRG_RST(); 
    287              
    288              {
    289          #if CLIENT
    290                  uint8_t bdaddr[] = {0xbb, 0x00, 0x00, 0xE1, 0x80, 0x02};
    291          #else
    292                  uint8_t bdaddr[] = {0xaa, 0x00, 0x00, 0xE1, 0x80, 0x02};
    293          #endif
    294                  ret = aci_hal_write_config_data(CONFIG_DATA_PUBADDR_OFFSET, CONFIG_DATA_PUBADDR_LEN,
    295                                                  bdaddr);
    296                  if(ret){
    297                      PRINTF("Setting BD_ADDR failed.\n");
    298                  }
    299              }
    300              
    301              ret = aci_gatt_init();    
    302              if(ret){
    303                  PRINTF("GATT_Init failed.\n");
    304              }
    305              
    306              {
    307                  uint16_t service_handle, dev_name_char_handle, appearance_char_handle;
    308          #if SERVER
    309                  ret = aci_gap_init(GAP_PERIPHERAL_ROLE, &service_handle, &dev_name_char_handle, &appearance_char_handle);
    310          #else
    311                  ret = aci_gap_init(GAP_CENTRAL_ROLE, &service_handle, &dev_name_char_handle, &appearance_char_handle);
    312          #endif
    313                  if(ret){
    314                      PRINTF("GAP_Init failed.\n");
    315                  }
    316              }
    317            
    318              /*ret = aci_gap_set_auth_requirement(MITM_PROTECTION_REQUIRED,
    319                                                 OOB_AUTH_DATA_ABSENT,
    320                                                 NULL,
    321                                                 7,
    322                                                 16,
    323                                                 USE_FIXED_PIN_FOR_PAIRING,       
    324                                                 123456,
    325                                                 BONDING);
    326              PRINTF("BLE Stack Initialized.\r\n");*/
    327              
    328          #if  SERVER
    329              PRINTF("SERVER: BLE Stack Initialized (platform: %d)\n\r", SdkEvalGetVersion());
    330              ret = Add_Chat_Service();
    331              
    332              if(ret == BLE_STATUS_SUCCESS)
    333                  PRINTF("Service added successfully.\r\n");
    334              else
    335                  PRINTF("Error while adding service.\r\n");
    336              
    337          #else
    338              PRINTF("CLIENT: BLE Stack Initialized  (platform: %d)\n\r", SdkEvalGetVersion());
    339          #endif 
    340              
    341              /* -2 dBm output power */
    342              ret = aci_hal_set_tx_power_level(1,4);
    343                  
    344              while(1)
    345              { 
    346                  HCI_Process();
    347                  User_Process();
    348                  //Clock_Wait(10000);
    349              }
    350          }
    351          
    352          /**
    353            * @brief  Make the device connectable
    354            * @param  None 
    355            * @retval None
    356            */
    357          void Make_Connection(void)
    358          {  
    359              tBleStatus ret;
    360              
    361              
    362          #if CLIENT
    363              tBDAddr bdaddr = {0xaa, 0x00, 0x00, 0xE1, 0x80, 0x02};
    364              
    365              //ret = aci_gap_create_connection(0x4000, 0x4000, PUBLIC_ADDR, bdaddr, PUBLIC_ADDR, 40, 40, 0, 60, 2000 , 2000); 
    366              ret = aci_gap_create_connection(0x4000, 0x4000, PUBLIC_ADDR, bdaddr, PUBLIC_ADDR, 9, 9, 0, 60, 1000 , 1000); 
    367              if (ret != 0){
    368                  PRINTF("Error while starting connection.\n");
    369                  Clock_Wait(100);        
    370          	}
    371          #else
    372              
    373              const char local_name[] = {AD_TYPE_COMPLETE_LOCAL_NAME,'B','l','u','e','N','R','G','_','C','h','a','t'};
    374              
    375              /* disable scan response */
    376              //hci_le_set_scan_resp_data(0,NULL);
    377              
    378              PRINTF("General Discoverable Mode ");
    379              ret = aci_gap_set_discoverable(ADV_IND, 0x00a0, 0x00a0, PUBLIC_ADDR, 0x00,
    380                                             13, local_name, 0, 0x0, 0, 0);
    381          
    382              PRINTF("%d\n\r",ret);
    383          #endif
    384          }
    385          
    386          /**
    387            * @brief  This function is called when there is a LE Connection Complete event.
    388            * @param  addr Address of peer device
    389            * @param  handle Connection handle
    390            * @retval None
    391            */
    392          void GAP_ConnectionComplete_CB(uint8_t addr[6], uint16_t handle)
    393          {    
    394              APP_FLAG_SET(CONNECTED); 
    395              connection_handle = handle;
    396              
    397              //Show connection with LED
    398              turnLED(3,ON);
    399              //numConnected += 1;
    400              //if(numConnected != 2)
    401                //APP_FLAG_SET(SET_CONNECTABLE);
    402              
    403              PRINTF("Connected to device:");
    404              for(int i = 5; i > 0; i--){
    405                  PRINTF("%02X-", addr[i]);
    406              }
    407              PRINTF("%02X\n\r", addr[0]);
    408              
    409          #if REQUEST_CONN_PARAM_UPDATE
    410              APP_FLAG_CLEAR(L2CAP_PARAM_UPD_SENT);
    411              Timer_Set(&l2cap_req_timer, CLOCK_SECOND*2);
    412          #endif
    413              
    414          }
    415          
    416          /**
    417            * @brief  This function is called when the peer device get disconnected.
    418            * @param  None 
    419            * @retval None
    420            */
    421          void GAP_DisconnectionComplete_CB(void)
    422          {
    423            //Turn off connection LED
    424            turnLED(3,OFF);
    425            //numConnected -+ 1;
    426              APP_FLAG_CLEAR(CONNECTED);
    427              PRINTF("Disconnected\n\r");
    428              /* Make the device connectable again. */
    429              APP_FLAG_SET(SET_CONNECTABLE);
    430              APP_FLAG_CLEAR(NOTIFICATIONS_ENABLED);
    431              
    432              APP_FLAG_CLEAR(START_READ_TX_CHAR_HANDLE);
    433              APP_FLAG_CLEAR(END_READ_TX_CHAR_HANDLE);
    434              APP_FLAG_CLEAR(START_READ_RX_CHAR_HANDLE); 
    435              APP_FLAG_CLEAR(END_READ_RX_CHAR_HANDLE); 
    436          }
    437          
    438          /**
    439            * @brief  This function is called when there is a notification from the sever.
    440            * @param  attr_handle Handle of the attribute
    441            * @param  attr_len    Length of attribute value in the notification
    442            * @param  attr_value  Attribute value in the notification
    443            * @retval None
    444            */
    445          void GATT_Notification_CB(uint16_t attr_handle, uint8_t attr_len, uint8_t *attr_value)
    446          {
    447          #if THROUGHPUT_TEST && CLIENT
    448              static tClockTime time, time2;
    449              static int packets=0;     
    450              
    451              if(attr_handle == tx_handle+1){ 
    452                  if(packets==0){
    453                      printf("Test start\n\r");
    454                      time = Clock_Time();
    455                  }
    456                  
    457                  for(int i = 0; i < attr_len; i++)
    458                      printf("%c", attr_value[i]);
    459                  
    460                  printf("[RX: %d]", packets);//TBR
    461                  
    462                  packets++;
    463                  
    464                  if(packets == NUM_PACKETS){
    465                      time2 = Clock_Time();
    466                      tClockTime diff = time2-time;
    467                      printf("\n%d packets. Elapsed time: %d ms. App throughput: %.2f kbps.\n\r", NUM_PACKETS, diff, (float)NUM_PACKETS*20*8/diff);
    468                  }        
    469                  
    470              }
    471          #elif CLIENT
    472              
    473              if(attr_handle == tx_handle+1){
    474                for(int i = 0; i < attr_len; i++)
    475                    printf("%c", attr_value[i]);
    476              }
    477          #endif
    478          }
    479          
    480          void User_Process(void)
    481          {
    482              if(APP_FLAG(SET_CONNECTABLE)){
    483                  Make_Connection();
    484                  APP_FLAG_CLEAR(SET_CONNECTABLE);
    485              }
    486          
    487          #if REQUEST_CONN_PARAM_UPDATE    
    488              if(APP_FLAG(CONNECTED) && !APP_FLAG(L2CAP_PARAM_UPD_SENT) && Timer_Expired(&l2cap_req_timer)){
    489                  aci_l2cap_connection_parameter_update_request(connection_handle, 8, 16, 0, 600);
    490                  APP_FLAG_SET(L2CAP_PARAM_UPD_SENT);
    491              }
    492          #endif
    493              
    494          #if CLIENT
    495              
    496              
    497              /* Start TX handle Characteristic discovery if not yet done */
    498              if (APP_FLAG(CONNECTED) && !APP_FLAG(END_READ_TX_CHAR_HANDLE))
    499              {
    500                if (!APP_FLAG(START_READ_TX_CHAR_HANDLE))
    501                {
    502                  /* Discovery TX characteristic handle by UUID 128 bits */
    503                  
    504                   const uint8_t charUuid128_TX[16] = {0x66,0x9a,0x0c,0x20,0x00,0x08,0x96,0x9e,0xe2,0x11,0x9e,0xb1,0xe1,0xf2,0x73,0xd9};
    505                   
    506                   aci_gatt_disc_charac_by_uuid(connection_handle, 0x0001, 0xFFFF,UUID_TYPE_128,
    507                                                             charUuid128_TX);
    508                   APP_FLAG_SET(START_READ_TX_CHAR_HANDLE);
    509                }
    510              }
    511              /* Start RX handle Characteristic discovery if not yet done */
    512              else if (APP_FLAG(CONNECTED) && !APP_FLAG(END_READ_RX_CHAR_HANDLE))
    513              {
    514                /* Discovery RX characteristic handle by UUID 128 bits */
    515                if (!APP_FLAG(START_READ_RX_CHAR_HANDLE))
    516                {
    517                  /* Discovery TX characteristic handle by UUID 128 bits */
    518                  
    519                   const uint8_t charUuid128_RX[16] = {0x66,0x9a,0x0c,0x20,0x00,0x08,0x96,0x9e,0xe2,0x11,0x9e,0xb1,0xe2,0xf2,0x73,0xd9};
    520                   aci_gatt_disc_charac_by_uuid(connection_handle, 0x0001, 0xFFFF,UUID_TYPE_128,
    521                                                             charUuid128_RX);
    522                   APP_FLAG_SET(START_READ_RX_CHAR_HANDLE);
    523                 }
    524              }
    525              
    526              if(APP_FLAG(CONNECTED) && APP_FLAG(END_READ_TX_CHAR_HANDLE) && APP_FLAG(END_READ_RX_CHAR_HANDLE) && !APP_FLAG(NOTIFICATIONS_ENABLED)){
    527                  uint8_t client_char_conf_data[] = {0x01, 0x00}; // Enable notifications
    528                  struct timer t;
    529                  Timer_Set(&t, CLOCK_SECOND*10);
    530                  
    531                  while(aci_gatt_write_charac_descriptor(connection_handle, tx_handle+2, 2, client_char_conf_data)==BLE_STATUS_NOT_ALLOWED){ //TX_HANDLE;
    532                      // Radio is busy.
    533                      if(Timer_Expired(&t)) break;
    534                  }
    535                  APP_FLAG_SET(NOTIFICATIONS_ENABLED);
    536                }
    537              else if(APP_FLAG(CONNECTED) && APP_FLAG(END_READ_TX_CHAR_HANDLE) && APP_FLAG(END_READ_RX_CHAR_HANDLE) && APP_FLAG(NOTIFICATIONS_ENABLED)){
    538                uint8_t data_buffer[] = {0x48,0x45,0x4c,0x4c,0x4f,0x0d};
    539                uint16_t Nb_bytes = 6;
    540                processInputData(data_buffer, Nb_bytes);
    541                Clock_Wait(1000);
    542                }
    543             
    544          #endif
    545              
    546              
    547          #if THROUGHPUT_TEST && SERVER
    548              
    549              
    550              static uint8_t test_done = FALSE;
    551              
    552              if(APP_FLAG(CONNECTED) && !test_done && APP_FLAG(NOTIFICATIONS_ENABLED)){
    553              
    554                  uint8_t data[20] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J'};
    555                  
    556                  static tClockTime time, time2;
    557                  time = Clock_Time();
    558                  
    559                  for(int i = 0; i < NUM_PACKETS; i++){
    560                      
    561                      struct timer t;
    562                      Timer_Set(&t, CLOCK_SECOND*10);
    563                                      
    564                      while(aci_gatt_update_char_value(chatServHandle, TXCharHandle, 0, 20, data)==BLE_STATUS_INSUFFICIENT_RESOURCES)
    565                      {
    566                        // Radio is busy (buffer full).
    567                        if(Timer_Expired(&t))
    568                            break;
    569                      }
    570                  
    571                  }
    572                  
    573                  time2 = Clock_Time();
    574                  tClockTime diff = time2-time;
    575                  printf("\n%d packets. Elapsed time: %d ms. App throughput: %.2f kbps.\n\r", NUM_PACKETS, diff, (float)NUM_PACKETS*20*8/diff);
    576                  
    577                  test_done = TRUE;
    578              }
    579          #endif
    580              
    581          }
    582          
    583          /**
    584            * @brief  This function is called whenever there is an ACI event to be processed.
    585            * @note   Inside this function each event must be identified and correctly
    586            *         parsed.
    587            * @param  pckt  Pointer to the ACI packet
    588            * @retval None
    589            */
    590          void HCI_Event_CB(void *pckt)
    591          {
    592              hci_uart_pckt *hci_pckt = pckt;
    593              hci_event_pckt *event_pckt = (hci_event_pckt*)hci_pckt->data;
    594              
    595              if(hci_pckt->type != HCI_EVENT_PKT)
    596                  return;
    597              
    598              switch(event_pckt->evt){
    599                  
    600              case EVT_DISCONN_COMPLETE:
    601                  {
    602                      GAP_DisconnectionComplete_CB();
    603                  }
    604                  break;
    605                  
    606              case EVT_LE_META_EVENT:
    607                  {
    608                      evt_le_meta_event *evt = (void *)event_pckt->data;
    609                      
    610                      switch(evt->subevent){
    611                      case EVT_LE_CONN_COMPLETE:
    612                          {
    613                              evt_le_connection_complete *cc = (void *)evt->data;
    614                              GAP_ConnectionComplete_CB(cc->peer_bdaddr, cc->handle);
    615                          }
    616                          break;
    617                      }
    618                  }
    619                  break;
    620                  
    621              case EVT_VENDOR:
    622                  {
    623                      evt_blue_aci *blue_evt = (void*)event_pckt->data;
    624                      switch(blue_evt->ecode){
    625                          
    626                      case EVT_BLUE_GATT_ATTRIBUTE_MODIFIED:
    627                          {
    628                              evt_gatt_attr_modified *evt = (evt_gatt_attr_modified*)blue_evt->data;
    629                              Attribute_Modified_CB(evt->attr_handle, evt->data_length, evt->att_data);
    630                              
    631                              //Catch event
    632                              GPIO_ToggleBits(GPIOC,LED0);
    633                              uint16_t defined_hex = 0x45;
    634                              uint16_t handle = evt->attr_handle;
    635                              uint8_t data_length = evt->data_length;
    636                              uint8_t *att_data = evt->att_data;
    637                              if(handle == RXCharHandle + 1){
    638                                if(att_data[0] == defined_hex){
    639                                  // call function
    640                                   startTimer(2);
    641                                 }
    642                                 //Clock_Wait(100);
    643                                 //att_data[0] = att_data[0]+1;
    644                                 //processInputData(att_data, data_length);
    645                              }
    646                              
    647                          }
    648                          break;
    649                      case EVT_BLUE_GATT_NOTIFICATION:
    650                          {
    651                              evt_gatt_attr_notification *evt = (evt_gatt_attr_notification*)blue_evt->data;
    652                              GATT_Notification_CB(evt->attr_handle, evt->event_data_length - 2, evt->attr_value);
    653                          }
    654                          break;
    655                       case EVT_BLUE_L2CAP_CONN_UPD_RESP:
    656                          {
    657                              evt_l2cap_conn_upd_resp *resp = (void*)blue_evt->data;
    658                              if(resp->result){
    659                                  PRINTF("> Connection parameters rejected.\n");
    660                              }
    661                              else{
    662                                  PRINTF("> Connection parameters accepted.\n");
    663                              }
    664                          }
    665                          break;
    666          #ifdef CLIENT            
    667                        case EVT_BLUE_GATT_DISC_READ_CHAR_BY_UUID_RESP:
    668                          {
    669                              evt_gatt_disc_read_char_by_uuid_resp *resp = (void*)blue_evt->data;
    670                              
    671                              if (APP_FLAG(START_READ_TX_CHAR_HANDLE) && !APP_FLAG(END_READ_TX_CHAR_HANDLE))
    672                              {
    673                                tx_handle = resp->attr_handle;
    674                                PRINTF("TX Char Handle %04X\n\r", tx_handle);
    675                              }
    676                              else if (APP_FLAG(START_READ_RX_CHAR_HANDLE) && !APP_FLAG(END_READ_RX_CHAR_HANDLE))
    677                              {
    678                                rx_handle = resp->attr_handle;
    679                                PRINTF("RX Char Handle %04X\n\r", rx_handle);
    680                              }
    681                          }
    682                          break;  
    683                          
    684                          case EVT_BLUE_GATT_PROCEDURE_COMPLETE:
    685                          {
    686                            /* Wait for gatt procedure complete event trigger related to Discovery Charac by UUID */
    687                            //evt_gatt_procedure_complete *pr = (void*)blue_evt->data;
    688                            
    689                            if (APP_FLAG(START_READ_TX_CHAR_HANDLE) && !APP_FLAG(END_READ_TX_CHAR_HANDLE))
    690                            {
    691                              APP_FLAG_SET(END_READ_TX_CHAR_HANDLE);
    692                            }
    693                            else if (APP_FLAG(START_READ_RX_CHAR_HANDLE) && !APP_FLAG(END_READ_RX_CHAR_HANDLE))
    694                            {
    695                              APP_FLAG_SET(END_READ_RX_CHAR_HANDLE);
    696                            }
    697                          }
    698                          break;
    699          #endif         
    700                      }
    701                  }
    702                  break;
    703              }
    704              
    705          }
    706          
    707          
    708          #ifdef USE_FULL_ASSERT
    709          /*******************************************************************************
    710          * Function Name  : assert_failed
    711          * Description    : Reports the name of the source file and the source line number
    712          *                  where the assert_param error has occurred.
    713          * Input          : - file: pointer to the source file name
    714          *                  - line: assert_param error line source number
    715          * Output         : None
    716          * Return         : None
    717          *******************************************************************************/
    718          void assert_failed(uint8_t* file, uint32_t line)
    719          {
    720              /* User can add his own implementation to report the file name and line number,
    721              ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
    722              
    723              /* Infinite loop */
    724              while (1)
    725              {
    726                printf("\r\nFailed\r\n");
    727                Clock_Wait(10000);
    728              }
    729          }
    730          #endif
    731          
    732          /******************* (C) COPYRIGHT 2014 STMicroelectronics *****END OF FILE****/
    733          /** \endcond
    734           */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   GAP_ConnectionComplete_CB
         0   -> printf
        16   -> printf
        16   -> turnLED
       8   GAP_DisconnectionComplete_CB
         8   -> printf
         8   -> turnLED
       0   GATT_Notification_CB
       8   HCI_Event_CB
         8   -> Attribute_Modified_CB
         0   -> GAP_ConnectionComplete_CB
         0   -> GAP_DisconnectionComplete_CB
         8   -> GPIO_ToggleBits
         0   -> printf
         0   -> startTimer
      56   Make_Connection
        56   -> aci_gap_set_discoverable
        56   -> printf
      64   User_Process
        64   -> aci_gap_set_discoverable
        64   -> printf
      64   main
        64   -> Add_Chat_Service
        64   -> BlueNRG_RST
        64   -> Clock_Init
        64   -> Clock_Wait
        64   -> FLASH_SLEEPPowerDownCmd
        64   -> HCI_Init
        64   -> HCI_Process
        64   -> Init_GPIOs
        64   -> NVIC_PriorityGroupConfig
        64   -> NVIC_SetVectorTable
        64   -> PWR_FastWakeUpCmd
        64   -> PWR_PVDCmd
        64   -> PWR_UltraLowPowerCmd
        64   -> RCC_Configuration
        64   -> SdkEvalGetVersion
        64   -> SdkEvalIdentification
        64   -> SdkEvalSpiInit
        64   -> SdkEval_IO_Config
        64   -> aci_gap_init
        64   -> aci_gap_set_discoverable
        64   -> aci_gatt_init
        64   -> aci_hal_set_tx_power_level
        64   -> aci_hal_write_config_data
        64   -> enableTimerInterrupt
        64   -> initLED
        64   -> initTimer
        64   -> printf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable21_4
       2  ?_0
       8  ?_1
       8  ?_10
      24  ?_11
       8  ?_12
       8  ?_13
      16  ?_14
      36  ?_15
      36  ?_16
      28  ?_2
      20  ?_3
      20  ?_4
      48  ?_5
      32  ?_6
      32  ?_7
      16  ?_8
      28  ?_9
      94  GAP_ConnectionComplete_CB
      78  GAP_DisconnectionComplete_CB
       2  GATT_Notification_CB
     148  HCI_Event_CB
      68  Make_Connection
      84  User_Process
       8  connection_handle
          app_flags
       8  l2cap_req_timer
     378  main

 
     8 bytes in section .bss
     8 bytes in section .data
     2 bytes in section .rodata
 1 240 bytes in section .text
 
 1 240 bytes of CODE  memory
     2 bytes of CONST memory
    16 bytes of DATA  memory

Errors: none
Warnings: 1
